{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "description": "Generated by xsd2code++. www.xsd2code.com",
  "definitions": {
    "ItemTarget": {
      "description": "A pointer to an element or attribute in an XML document.",
      "type": "object"
    },
    "BlobType": {
      "description": "Standard structure for including Binary Large Objects (Blobs) in XML\r  templates. Blobs can handle any type of binary media, such as images, audio, video,\r  and data streams of any specified format (such as a MIME type).",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Description": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RichTextType"
          }
        },
        "Hash": {
          "$ref": "#/definitions/HashType"
        },
        "BlobURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "BinaryMediaBase64": {
          "items": {
            "$ref": "#/definitions/base64Binary_Stype"
          }
        }
      }
    },
    "CodingType": {
      "description": "This type represents any type of coding, terminology, classification, keyword, or local value system that may be applied to any displayable item in a\r  FormDesign template.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Code": {
          "$ref": "#/definitions/string_Stype"
        },
        "TypedValue": {
          "$ref": "#/definitions/DataTypes_SType"
        },
        "CodeText": {
          "$ref": "#/definitions/RichTextType"
        },
        "CodeMatch": {
          "$ref": "#/definitions/CodeMatchType"
        },
        "CodeSystem": {
          "$ref": "#/definitions/CodeSystemType"
        },
        "CodeURI": {
          "$ref": "#/definitions/anyURI_Stype"
        },
        "Units": {
          "$ref": "#/definitions/UnitsType"
        }
      },
      "required": [
        "Code"
      ]
    },
    "CodeSystemType": {
      "description": "This type represents information about the coding system used in CodingType. It may refer to any type of coding, terminology, classification, keyword, or local value system.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "CodeSystemName": {
          "$ref": "#/definitions/string_Stype"
        },
        "ReleaseDate": {
          "$ref": "#/definitions/dateTime_Stype"
        },
        "Version": {
          "$ref": "#/definitions/string_Stype"
        },
        "OID": {
          "$ref": "#/definitions/string_Stype"
        },
        "CodeSystemURI": {
          "$ref": "#/definitions/anyURI_Stype"
        }
      },
      "required": [
        "CodeSystemName"
      ]
    },
    "ContactType": {
      "description": "A model structure for a Person or Organization that generally performs a particular stated role.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Person": {
          "$ref": "#/definitions/PersonType"
        },
        "Organization": {
          "$ref": "#/definitions/OrganizationType"
        }
      }
    },
    "PersonType": {
      "description": "A model structure for a Person object.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "PersonName": {
          "$ref": "#/definitions/NameType"
        },
        "AliasName": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NameType"
          }
        },
        "Job": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JobType"
          }
        },
        "StreetAddress": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AddressType"
          }
        },
        "Email": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EmailType"
          }
        },
        "Phone": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PhoneType"
          }
        },
        "WebURL": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "Role": {
          "$ref": "#/definitions/string_Stype"
        },
        "Identifier": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/IdentifierType"
          }
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "PersonName"
      ]
    },
    "JobType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "JobTitle": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "Organization": {
          "$ref": "#/definitions/OrganizationType"
        },
        "StartDate": {
          "$ref": "#/definitions/date_Stype"
        },
        "StopDate": {
          "$ref": "#/definitions/date_Stype"
        },
        "Description": {
          "$ref": "#/definitions/string_Stype"
        }
      }
    },
    "OrganizationType": {
      "description": "A model structure for an Organization object.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "OrgName": {
          "$ref": "#/definitions/string_Stype"
        },
        "Department": {
          "$ref": "#/definitions/string_Stype"
        },
        "StreetAddress": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AddressType"
          }
        },
        "Email": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EmailType"
          }
        },
        "Phone": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PhoneType"
          }
        },
        "WebURL": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "Role": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "ContactPerson": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PersonType"
          }
        },
        "Identifier": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/IdentifierType"
          }
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "OrgName"
      ]
    },
    "AddressType": {
      "description": "A structure for recording street/mailing addresses.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "AddressType": {
          "$ref": "#/definitions/string_Stype"
        },
        "InternalAddress": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          },
          "maxItems": 10
        },
        "AddressLine": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          },
          "maxItems": 10
        },
        "City": {
          "$ref": "#/definitions/string_Stype"
        },
        "Jurisdiction": {
          "$ref": "#/definitions/string_Stype"
        },
        "State": {
          "$ref": "#/definitions/string_Stype"
        },
        "PostalCode": {
          "$ref": "#/definitions/string_Stype"
        },
        "Country": {
          "$ref": "#/definitions/string_Stype"
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      }
    },
    "PhoneType": {
      "description": "A structure for recording telephone numbers.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "PhoneType": {
          "$ref": "#/definitions/string_Stype"
        },
        "CountryCode": {
          "$ref": "#/definitions/CountryCodeType"
        },
        "AreaCode": {
          "$ref": "#/definitions/AreaCodeType"
        },
        "PhoneNumber": {
          "$ref": "#/definitions/PhoneNumberType"
        },
        "PhoneExtension": {
          "$ref": "#/definitions/string_Stype"
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "PhoneNumber"
      ]
    },
    "EmailType": {
      "description": "A structure for recording email addresses.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "EmailAddress": {
          "$ref": "#/definitions/EmailAddressType"
        },
        "EmailClass": {
          "$ref": "#/definitions/string_Stype"
        },
        "Usage": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "EmailAddress"
      ]
    },
    "FileType": {
      "description": "Information about a file, usually thought of as a binary byte stream\r  stored on disk. A FileType can also represent a \"virtual\" file, such as an XML\r  module in a larger XML document. Such a virtual file could theoretically be stored\r  as a byte stream, as an independant file on disk or as a database record or set of\r  records, even if this byte stream is never actually persisted as an independant disk\r  file.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "FileID": {
          "$ref": "#/definitions/string_Stype"
        },
        "FileURI": {
          "$ref": "#/definitions/anyURI_Stype"
        },
        "DisplayName": {
          "$ref": "#/definitions/string_Stype"
        },
        "Title": {
          "$ref": "#/definitions/string_Stype"
        },
        "Version": {
          "$ref": "#/definitions/VersionType"
        },
        "FileName": {
          "$ref": "#/definitions/string_Stype"
        },
        "FileExtension": {
          "$ref": "#/definitions/string_Stype"
        },
        "FileClass": {
          "$ref": "#/definitions/string_Stype"
        },
        "FileSizeKB": {
          "$ref": "#/definitions/positiveInteger_Stype"
        },
        "Description": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "Copyright": {
          "$ref": "#/definitions/string_Stype"
        },
        "TermsofUse": {
          "$ref": "#/definitions/string_Stype"
        },
        "Usage": {
          "$ref": "#/definitions/FileUsageType"
        },
        "Dates": {
          "$ref": "#/definitions/FileDatesType"
        },
        "Contacts": {
          "$ref": "#/definitions/ContactsType"
        },
        "Approval": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ApprovalType"
          }
        },
        "FileHash": {
          "$ref": "#/definitions/FileHashType"
        },
        "Language": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LanguageType"
          }
        },
        "AssociatedFiles": {
          "$ref": "#/definitions/AssociatedFilesType"
        },
        "Provenance": {
          "$ref": "#/definitions/ProvenanceType"
        },
        "DefaultSubmissionRule": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SubmissionRuleType"
          }
        },
        "DefaultComplianceRule": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ComplianceRuleType"
          }
        }
      },
      "required": [
        "FileURI",
        "DisplayName"
      ]
    },
    "LanguageType": {
      "description": "A generic structure for recording languages.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Language": {
          "$ref": "#/definitions/string_Stype"
        },
        "LanguageCode.ISO.639.3": {
          "$ref": "#/definitions/LanguageCode.ISO.639.3_Type"
        }
      },
      "required": [
        "LanguageCode.ISO.639.3"
      ]
    },
    "VersionType": {
      "description": "A generic structure for recording file version metadata.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "VersioningReference": {
          "$ref": "#/definitions/FileType"
        },
        "VersionComments": {
          "$ref": "#/definitions/RichTextType"
        },
        "Changes": {
          "description": "Itemized list of changes in the new version",
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "Comment": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/CommentType"
              }
            },
            "Extension": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ExtensionType"
              }
            },
            "Property": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/PropertyType"
              }
            },
            "Change": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ChangeLogType"
              },
              "minItems": 1
            },
            "name": {
              "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
              "type": "string"
            },
            "type": {
              "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
              "type": "string"
            },
            "styleClass": {
              "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
              "type": "string"
            },
            "order": {
              "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
              "type": "number",
              "minimum": 0.0
            }
          }
        }
      }
    },
    "AcceptabilityType": {
      "type": "object"
    },
    "ChangeLogType": {
      "description": "Inforamtion about changes to file or part of a\r  file.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "ChangedField": {
          "$ref": "#/definitions/ChangedFieldType"
        },
        "ChangedTo": {
          "$ref": "#/definitions/DataTypes_SType"
        },
        "ChangedFrom": {
          "$ref": "#/definitions/DataTypes_SType"
        },
        "ChangeType": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          },
          "minItems": 1
        },
        "Replaces": {
          "$ref": "#/definitions/ReplacedIDsType"
        },
        "ChangeDate": {
          "$ref": "#/definitions/dateTime_Stype"
        },
        "ChangeDescription": {
          "$ref": "#/definitions/string_Stype"
        },
        "Editors": {
          "$ref": "#/definitions/ContactsType"
        },
        "ChangeTracking": {
          "$ref": "#/definitions/ChangeTrackingType"
        }
      },
      "required": [
        "ChangedField",
        "ChangedTo",
        "ChangedFrom",
        "ChangeDate"
      ]
    },
    "ChangeType": {
      "description": "A structure to describe a single change in an XML document",
      "type": "object"
    },
    "FileDatesType": {
      "description": "List of standard kinds of dates that may apply to a file or its usage.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "FileDate": {
          "$ref": "#/definitions/dateTime_Stype"
        },
        "PreviousRevisionDate": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/dateTime_Stype"
          }
        },
        "ReleaseDate": {
          "$ref": "#/definitions/dateTime_Stype"
        },
        "EffectiveDate": {
          "$ref": "#/definitions/dateTime_Stype"
        },
        "FirstReleaseDate": {
          "$ref": "#/definitions/dateTime_Stype"
        },
        "UsageStartDate": {
          "$ref": "#/definitions/dateTime_Stype"
        },
        "RetirementDate": {
          "$ref": "#/definitions/dateTime_Stype"
        },
        "OtherDate": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/dateTime_Stype"
          }
        }
      }
    },
    "RichTextType": {
      "description": "Representation of plain text with an option for HTML-formatting. Contains optional boilerplate metadata to aid programmatic manipulation.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "RichText": {
          "$ref": "#/definitions/HTML_Stype"
        }
      },
      "required": [
        "RichText"
      ]
    },
    "LinkType": {
      "description": "A hyperlink to an Internet endpoint such as a web page or web service.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "LinkText": {
          "$ref": "#/definitions/RichTextType"
        },
        "LinkURI": {
          "$ref": "#/definitions/anyURI_Stype"
        }
      },
      "required": [
        "LinkURI"
      ]
    },
    "UnitsType": {
      "description": "UnitsType represents the measurement standard and its abbreviated notation for quantifiable objects, e.g., miles, km, mm, cm, etc. The default system for standard notations is UCUM.",
      "type": "object"
    },
    "SubmissionRuleType": {
      "description": "information about where to submit a completed form",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Destination": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DestinationType"
          },
          "minItems": 1
        },
        "RuleDescription": {
          "$ref": "#/definitions/string_Stype"
        }
      }
    },
    "ComplianceRuleType": {
      "description": "General information about how information in a particular form package must be handled. This may include, e.g., security, completeness, transmission, and validation criteria.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Description": {
          "$ref": "#/definitions/string_Stype"
        },
        "ComplianceOrganization": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OrganizationType"
          }
        }
      },
      "required": [
        "Description"
      ]
    },
    "EmailAddressType": {
      "description": "***Changed from BaseType to ExtensionBaseType",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "PhoneNumberType": {
      "description": "***Changed from BaseType to ExtensionBaseType",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "AreaCodeType": {
      "type": "object"
    },
    "CountryCodeType": {
      "type": "object"
    },
    "LanguageCode.ISO.639.3_Type": {
      "type": "object"
    },
    "NameType": {
      "description": "Structure to define a person's name, including prefixes, suffixes, and degrees.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "NamePrefix": {
          "$ref": "#/definitions/string_Stype"
        },
        "FirstName": {
          "$ref": "#/definitions/string_Stype"
        },
        "MiddleName": {
          "$ref": "#/definitions/string_Stype"
        },
        "LastName": {
          "$ref": "#/definitions/string_Stype"
        },
        "NameSuffix": {
          "$ref": "#/definitions/string_Stype"
        },
        "DegreeCert": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "Title": {
          "$ref": "#/definitions/string_Stype"
        }
      },
      "required": [
        "FirstName",
        "LastName"
      ]
    },
    "IdentifierType": {
      "description": "A code or id that identifies a person or organization or object according to a standard system such as CLIA or NPI. The system should be specified in the @system attribute.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "IdentifiedExtensionType": {
      "description": "This is the base type for all subtypes that require a unique URI identifier.",
      "type": "object"
    },
    "TargetItemIDType": {
      "type": "object"
    },
    "TargetItemNameType": {
      "type": "object"
    },
    "TargetItemXPathType": {
      "type": "object"
    },
    "CodeMatchType": {
      "type": "object",
      "properties": {
        "CodingMatchComment": {
          "$ref": "#/definitions/string_Stype"
        }
      }
    },
    "DestinationType": {
      "description": "***Changed from BaseType to ExtensionBaseType",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Endpoint": {
          "$ref": "#/definitions/anyURI_Stype"
        },
        "EndpointDescription": {
          "$ref": "#/definitions/string_Stype"
        },
        "SubmissionTechnology": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "Organization": {
          "$ref": "#/definitions/OrganizationType"
        }
      },
      "required": [
        "Endpoint",
        "EndpointDescription"
      ]
    },
    "FileUsageType": {
      "type": "object"
    },
    "ContactsType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          },
          "minItems": 1
        }
      }
    },
    "ApprovalType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "ApprovalContact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "Description": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        }
      }
    },
    "FileHashType": {
      "type": "object"
    },
    "AssociatedFilesType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "File": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FileType"
          },
          "minItems": 1
        }
      }
    },
    "ProvenanceType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "ReplacedFile": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FileType"
          },
          "minItems": 1
        }
      }
    },
    "ReplacedIDsType": {
      "type": "object",
      "properties": {
        "ReplacedID": {
          "$ref": "#/definitions/anyURI_Stype"
        }
      },
      "required": [
        "ReplacedID"
      ]
    },
    "ChangeTrackingType": {
      "type": "object",
      "properties": {
        "ChangeTrackingID": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/string_Stype"
          },
          "minItems": 1
        }
      }
    },
    "ChangedFieldType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "TargetItemID": {
          "items": {
            "$ref": "#/definitions/TargetItemIDType"
          }
        },
        "TargetItemName": {
          "items": {
            "$ref": "#/definitions/TargetItemNameType"
          }
        },
        "TargetItemXPath": {
          "items": {
            "$ref": "#/definitions/TargetItemXPathType"
          }
        }
      }
    },
    "HashType": {
      "type": "object"
    },
    "PropertyType1": {
      "description": "MOVED: From SDCFormDesign\r CHANGED:\r Property is any type of data that is associated with any form item (e.g., section, question, list item) in any context. The Property context is specified by the @type attribute. Examples of @type values may include:\r -alternate language representations, e.g., 'spanish'\r -'instruction'\r -'tooltip' \r -'help' for a pop-up help box\r -'outlining' (such as question numbering)\r \r The @type enumerations must be defined and documented for the particular use case, and are currently out of scope in this schema definition. Multiple type tokens for a single element are supported.\r \r RENAMED: 'OtherText' to 'Property' 9/14/2016",
      "type": "object"
    },
    "PropertyType": {
      "description": "MOVED: From SDCFormDesign\r CHANGED:\r Property is any type of data that is associated with any form item (e.g., section, question, list item) in any context. The Property context is specified by the @type attribute. Examples of @type values may include:\r -alternate language representations, e.g., 'spanish'\r -'instruction'\r -'tooltip' \r -'help' for a pop-up help box\r -'outlining' (such as question numbering)\r \r The @type enumerations must be defined and documented for the particular use case, and are currently out of scope in this schema definition. Multiple type tokens for a single element are supported.\r \r RENAMED: 'OtherText' to 'Property' 9/14/2016",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "TypedValue": {
          "$ref": "#/definitions/DataTypes_SType"
        }
      }
    },
    "ExtensionBaseType": {
      "type": "object"
    },
    "DataTypes_DEType": {
      "description": "MOVED from SDCDataTypes:\r SDC datatypes for Data Entry (DE), based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. Includes additonal metadata to specify data input restrictions for data entry forms, and to aid in validation of IHE RFD SubmitForm responses in XML instance documents.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "anyType": {
          "items": {
            "$ref": "#/definitions/anyType_DEtype"
          }
        },
        "anyURI": {
          "items": {
            "$ref": "#/definitions/anyURI_DEtype"
          }
        },
        "base64Binary": {
          "items": {
            "$ref": "#/definitions/base64Binary_DEtype"
          }
        },
        "boolean": {
          "items": {
            "$ref": "#/definitions/boolean_DEtype"
          }
        },
        "duration": {
          "items": {
            "$ref": "#/definitions/duration_DEtype"
          }
        },
        "byte": {
          "items": {
            "$ref": "#/definitions/byte_DEtype"
          }
        },
        "date": {
          "items": {
            "$ref": "#/definitions/date_DEtype"
          }
        },
        "dateTimeStamp": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_DEtype"
          }
        },
        "decimal": {
          "items": {
            "$ref": "#/definitions/decimal_DEtype"
          }
        },
        "dateTime": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_DEtype"
          }
        },
        "double": {
          "items": {
            "$ref": "#/definitions/double_DEtype"
          }
        },
        "float": {
          "items": {
            "$ref": "#/definitions/float_DEtype"
          }
        },
        "gDay": {
          "items": {
            "$ref": "#/definitions/gDay_DEtype"
          }
        },
        "gMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_DEtype"
          }
        },
        "gMonthDay": {
          "items": {
            "$ref": "#/definitions/gMonthDay_DEtype"
          }
        },
        "gYear": {
          "items": {
            "$ref": "#/definitions/gYear_DEtype"
          }
        },
        "gYearMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_DEtype"
          }
        },
        "hexBinary": {
          "items": {
            "$ref": "#/definitions/hexBinary_DEtype"
          }
        },
        "HTML": {
          "items": {
            "$ref": "#/definitions/HTML_DEtype"
          }
        },
        "int": {
          "items": {
            "$ref": "#/definitions/int_DEtype"
          }
        },
        "integer": {
          "items": {
            "$ref": "#/definitions/integer_DEtype"
          }
        },
        "long": {
          "items": {
            "$ref": "#/definitions/long_DEtype"
          }
        },
        "negativeInteger": {
          "items": {
            "$ref": "#/definitions/negativeInteger_DEtype"
          }
        },
        "nonNegativeInteger": {
          "items": {
            "$ref": "#/definitions/nonNegativeInteger_DEtype"
          }
        },
        "nonPositiveInteger": {
          "items": {
            "$ref": "#/definitions/nonPositiveInteger_DEtype"
          }
        },
        "positiveInteger": {
          "items": {
            "$ref": "#/definitions/positiveInteger_DEtype"
          }
        },
        "short": {
          "items": {
            "$ref": "#/definitions/short_DEtype"
          }
        },
        "string": {
          "items": {
            "$ref": "#/definitions/string_DEtype"
          }
        },
        "time": {
          "items": {
            "$ref": "#/definitions/time_DEtype"
          }
        },
        "unsignedByte": {
          "items": {
            "$ref": "#/definitions/unsignedByte_DEtype"
          }
        },
        "unsignedInt": {
          "items": {
            "$ref": "#/definitions/unsignedInt_DEtype"
          }
        },
        "unsignedLong": {
          "items": {
            "$ref": "#/definitions/unsignedLong_DEtype"
          }
        },
        "unsignedShort": {
          "items": {
            "$ref": "#/definitions/unsignedShort_DEtype"
          }
        },
        "XML": {
          "items": {
            "$ref": "#/definitions/XML_DEtype"
          }
        },
        "yearMonthDuration": {
          "items": {
            "$ref": "#/definitions/yearMonthDuration_DEtype"
          }
        }
      }
    },
    "DataTypesNumeric_DEType": {
      "description": "NEW:\r SDC datatypes for Data Entry (DE), based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. Includes additonal metadata to specify data input restrictions for data entry forms, and to aid in validation of IHE RFD SubmitForm responses in XML instance documents.",
      "type": "object"
    },
    "DataTypesNumeric_SType": {
      "description": "NEW:\r SDC datatypes in Simple (S) format, based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. **CHECK for ERRORS and completeness**",
      "type": "object"
    },
    "DataTypesDateTime_DEType": {
      "description": "NEW:\r SDC datatypes for Data Entry (DE), based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. Includes additonal metadata to specify data input restrictions for data entry forms, and to aid in validation of IHE RFD SubmitForm responses in XML instance documents.",
      "type": "object"
    },
    "DataTypesDateTime_SType": {
      "description": "NEW:\r SDC datatypes in Simple (S) format, based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. **CHECK for ERRORS and completeness**",
      "type": "object"
    },
    "DataTypes_SType": {
      "description": "MOVED from SDCDataTypes:\r SDC datatypes in Simple (S) format, based mostly on W3C specifications. Uses baseAttributes and Extension capability to enhance the list of Data Types. **CHECK for ERRORS and completeness**",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "anyType": {
          "items": {
            "$ref": "#/definitions/anyType_DEtype"
          }
        },
        "anyURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "base64Binary": {
          "items": {
            "$ref": "#/definitions/base64Binary_Stype"
          }
        },
        "boolean": {
          "items": {
            "$ref": "#/definitions/boolean_Stype"
          }
        },
        "duration": {
          "items": {
            "$ref": "#/definitions/duration_Stype"
          }
        },
        "byte": {
          "items": {
            "$ref": "#/definitions/byte_Stype"
          }
        },
        "date": {
          "items": {
            "$ref": "#/definitions/date_Stype"
          }
        },
        "dateTimeStamp": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_Stype"
          }
        },
        "decimal": {
          "items": {
            "$ref": "#/definitions/decimal_Stype"
          }
        },
        "dateTime": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_Stype"
          }
        },
        "double": {
          "items": {
            "$ref": "#/definitions/double_Stype"
          }
        },
        "float": {
          "items": {
            "$ref": "#/definitions/float_Stype"
          }
        },
        "gDay": {
          "items": {
            "$ref": "#/definitions/gDay_Stype"
          }
        },
        "gMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_Stype"
          }
        },
        "gMonthDay": {
          "items": {
            "$ref": "#/definitions/gMonthDay_Stype"
          }
        },
        "gYear": {
          "items": {
            "$ref": "#/definitions/gYear_Stype"
          }
        },
        "gYearMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_Stype"
          }
        },
        "hexBinary": {
          "items": {
            "$ref": "#/definitions/hexBinary_Stype"
          }
        },
        "HTML": {
          "items": {
            "$ref": "#/definitions/HTML_Stype"
          }
        },
        "int": {
          "items": {
            "$ref": "#/definitions/int_Stype"
          }
        },
        "integer": {
          "items": {
            "$ref": "#/definitions/integer_Stype"
          }
        },
        "long": {
          "items": {
            "$ref": "#/definitions/long_Stype"
          }
        },
        "negativeInteger": {
          "items": {
            "$ref": "#/definitions/negativeInteger_Stype"
          }
        },
        "nonNegativeInteger": {
          "items": {
            "$ref": "#/definitions/nonNegativeInteger_Stype"
          }
        },
        "nonPositiveInteger": {
          "items": {
            "$ref": "#/definitions/nonPositiveInteger_Stype"
          }
        },
        "positiveInteger": {
          "items": {
            "$ref": "#/definitions/positiveInteger_Stype"
          }
        },
        "short": {
          "items": {
            "$ref": "#/definitions/short_Stype"
          }
        },
        "string": {
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "time": {
          "items": {
            "$ref": "#/definitions/time_Stype"
          }
        },
        "unsignedByte": {
          "items": {
            "$ref": "#/definitions/unsignedByte_Stype"
          }
        },
        "unsignedInt": {
          "items": {
            "$ref": "#/definitions/unsignedInt_Stype"
          }
        },
        "unsignedLong": {
          "items": {
            "$ref": "#/definitions/unsignedLong_Stype"
          }
        },
        "unsignedShort": {
          "items": {
            "$ref": "#/definitions/unsignedShort_Stype"
          }
        },
        "XML": {
          "items": {
            "$ref": "#/definitions/XML_Stype"
          }
        },
        "yearMonthDuration": {
          "items": {
            "$ref": "#/definitions/yearMonthDuration_Stype"
          }
        }
      }
    },
    "ItemNameType": {
      "description": "Moved from SDCFormDesign\r The type is a standard way to point to a named item anywhere in a FormDesign template. A named item is any element that has the @name attribute set to a unique value.",
      "type": "object"
    },
    "ItemNameAttributeType": {
      "description": "Moved from SDCFormDesign\r The type is a standard way to point to a named item anywhere in a FormDesign template. A named item is any element that has the @name attribute set to a unique value.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "Acceptability_StypeEnum": {
      "description": "Enumeration for specifying the level of aceptability for SDC form items.",
      "type": "string",
      "enum": [
        "preferred",
        "admitted",
        "deprecated",
        "obsolete",
        "superseded"
      ]
    },
    "EmailAddress_Stype": {
      "type": "string",
      "pattern": "[a-zA-Z0-9_\\-\\.\\+-]+@[a-zA-Z0-9\\-]+\\.[a-zA-Z0-9_\\-\\.]+"
    },
    "PhoneNumber_Stype": {
      "type": "string",
      "pattern": "\\+?\\(?\\d{2,4}\\)?[\\d\\s-]{3,}"
    },
    "AreaCode_Stype": {
      "type": "object",
      "maximum": 999.0
    },
    "CountryCode_Stype": {
      "type": "object",
      "maximum": 99.0
    },
    "LanguageCode.ISO.639.3_StypeEnum": {
      "description": "Based on ISO-639-3 Language Codes. See:\r  https://en.wikipedia.org/wiki/ISO_639:e",
      "type": "string",
      "enum": [
        "eng",
        "esp",
        "fra"
      ]
    },
    "MappingType": {
      "description": "This type supports the mapping of the targeted template items to any other template items or code system. The @type tokens include PrePop, AutoPop, SNOMED, LOINC, Keys, LocalValues, etc.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "DefaultCodeSystem": {
          "$ref": "#/definitions/CodeSystemType"
        },
        "ItemMap": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ItemMapType"
          },
          "minItems": 1
        }
      }
    },
    "DataStoreType": {
      "type": "object"
    },
    "SQL_Type": {
      "type": "object"
    },
    "XQueryType": {
      "type": "object"
    },
    "XPathType": {
      "type": "object"
    },
    "DataSourceType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Database": {
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "SecurityInfo": {
                "description": "Logon credentials should be provided only if the connection is trusted, secure, and encrypted. Whenever possible, this information should not be communicated in this manner, and another security model should be adopted.",
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "password": {
                    "type": "string"
                  },
                  "userName": {
                    "type": "string"
                  },
                  "val": {
                    "type": "string"
                  },
                  "name": {
                    "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                    "type": "string"
                  },
                  "type": {
                    "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                    "type": "string"
                  },
                  "styleClass": {
                    "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                    "type": "string"
                  },
                  "order": {
                    "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                    "type": "number",
                    "minimum": 0.0
                  }
                }
              },
              "DataStoreLocation": {
                "$ref": "#/definitions/string_Stype"
              },
              "DatabaseSoftware": {
                "$ref": "#/definitions/string_Stype"
              },
              "DatabaseName": {
                "$ref": "#/definitions/string_Stype"
              },
              "ConnectiontonString": {
                "$ref": "#/definitions/string_Stype"
              },
              "OtherConnectionParameters": {
                "$ref": "#/definitions/string_Stype"
              },
              "SQL": {
                "$ref": "#/definitions/SQL_Type"
              },
              "name": {
                "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                "type": "string"
              },
              "order": {
                "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                "type": "number",
                "minimum": 0.0
              }
            },
            "required": [
              "DataStoreLocation",
              "DatabaseSoftware",
              "DatabaseName",
              "ConnectiontonString",
              "SQL"
            ]
          }
        },
        "RDF_Store": {
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "SecurityInfo": {
                "type": "object"
              },
              "DataStoreLocation": {
                "$ref": "#/definitions/string_Stype"
              },
              "DatabaseSoftware": {
                "$ref": "#/definitions/string_Stype"
              },
              "DatabaseName": {
                "$ref": "#/definitions/string_Stype"
              },
              "ConnectiontonString": {
                "$ref": "#/definitions/string_Stype"
              },
              "OtherConnectionParameters": {
                "$ref": "#/definitions/string_Stype"
              },
              "SPARQL": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "version": {
                    "type": "string"
                  }
                }
              },
              "name": {
                "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                "type": "string"
              },
              "order": {
                "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                "type": "number",
                "minimum": 0.0
              }
            },
            "required": [
              "DataStoreLocation",
              "DatabaseSoftware",
              "DatabaseName",
              "ConnectiontonString",
              "SPARQL"
            ]
          }
        },
        "XML": {
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "SecurityInfo": {
                "type": "object"
              },
              "DataStoreLocation": {
                "$ref": "#/definitions/string_Stype"
              },
              "DatabaseSoftware": {
                "$ref": "#/definitions/string_Stype"
              },
              "DatabaseName": {
                "$ref": "#/definitions/string_Stype"
              },
              "ConnectiontonString": {
                "$ref": "#/definitions/string_Stype"
              },
              "OtherConnectionParameters": {
                "$ref": "#/definitions/string_Stype"
              },
              "XPath": {
                "items": {
                  "$ref": "#/definitions/XPathType"
                }
              },
              "ItemID": {
                "items": {
                  "$ref": "#/definitions/string_Stype"
                }
              },
              "SQL": {
                "items": {
                  "$ref": "#/definitions/SQL_Type"
                }
              },
              "XQuery": {
                "items": {
                  "$ref": "#/definitions/XQueryType"
                }
              },
              "name": {
                "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                "type": "string"
              },
              "order": {
                "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                "type": "number",
                "minimum": 0.0
              }
            },
            "required": [
              "DataStoreLocation",
              "DatabaseSoftware",
              "DatabaseName",
              "ConnectiontonString"
            ]
          }
        },
        "MappedCode": {
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        }
      }
    },
    "TemplateTargetType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "TargetItemID": {
          "$ref": "#/definitions/anyURI_Stype"
        },
        "TargetDisplayText": {
          "$ref": "#/definitions/RichTextType"
        }
      },
      "required": [
        "TargetItemID"
      ]
    },
    "ItemMapType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "TemplateTarget": {
          "$ref": "#/definitions/TemplateTargetType"
        },
        "DataSource": {
          "$ref": "#/definitions/DataSourceType"
        },
        "MapComment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RichTextType"
          }
        }
      },
      "required": [
        "TemplateTarget",
        "DataSource"
      ]
    },
    "ParameterGroup": {
      "type": "object"
    },
    "ParameterItemType": {
      "description": "Parameters are named, uniquely identifiable, instances of form attributes (e.g., @selected). They are fed into expressions, which are then used as part of a rule within the form. Parameters can also be fed into URI expressions used inside a Lookup Endpoint, i.e., URIs that call web services to supply list items (e.g., a list of SNOMED-coded items) to a question.\r \r Parameters using this construct are derived from other locations in the XML instance document, including user-entered Response values.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "ListItemParameterType": {
      "description": "Parameters are named, uniquely identifiable, instances of form attributes (e.g., @selected). They are fed into expressions, which are then used as part of a rule within the form. Parameters can also be fed into URI expressions used inside a Lookup Endpoint, i.e., URIs that call web services to supply list items (e.g., a list of SNOMED-coded items) to a question.\r \r Parameters using this construct are derived from other locations in the XML instance document, including user-entered Response values.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "ParameterValueType": {
      "description": "This type describes strongly-typed parameters used in functions and web services. Values are hard-coded as constants in the XML instance document. They are not user-entered values.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "anyType": {
          "items": {
            "$ref": "#/definitions/anyType_DEtype"
          }
        },
        "anyURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "base64Binary": {
          "items": {
            "$ref": "#/definitions/base64Binary_Stype"
          }
        },
        "boolean": {
          "items": {
            "$ref": "#/definitions/boolean_Stype"
          }
        },
        "duration": {
          "items": {
            "$ref": "#/definitions/duration_Stype"
          }
        },
        "byte": {
          "items": {
            "$ref": "#/definitions/byte_Stype"
          }
        },
        "date": {
          "items": {
            "$ref": "#/definitions/date_Stype"
          }
        },
        "dateTimeStamp": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_Stype"
          }
        },
        "decimal": {
          "items": {
            "$ref": "#/definitions/decimal_Stype"
          }
        },
        "dateTime": {
          "items": {
            "$ref": "#/definitions/dateTimeStamp_Stype"
          }
        },
        "double": {
          "items": {
            "$ref": "#/definitions/double_Stype"
          }
        },
        "float": {
          "items": {
            "$ref": "#/definitions/float_Stype"
          }
        },
        "gDay": {
          "items": {
            "$ref": "#/definitions/gDay_Stype"
          }
        },
        "gMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_Stype"
          }
        },
        "gMonthDay": {
          "items": {
            "$ref": "#/definitions/gMonthDay_Stype"
          }
        },
        "gYear": {
          "items": {
            "$ref": "#/definitions/gYear_Stype"
          }
        },
        "gYearMonth": {
          "items": {
            "$ref": "#/definitions/gMonth_Stype"
          }
        },
        "hexBinary": {
          "items": {
            "$ref": "#/definitions/hexBinary_Stype"
          }
        },
        "HTML": {
          "items": {
            "$ref": "#/definitions/HTML_Stype"
          }
        },
        "int": {
          "items": {
            "$ref": "#/definitions/int_Stype"
          }
        },
        "integer": {
          "items": {
            "$ref": "#/definitions/integer_Stype"
          }
        },
        "long": {
          "items": {
            "$ref": "#/definitions/long_Stype"
          }
        },
        "negativeInteger": {
          "items": {
            "$ref": "#/definitions/negativeInteger_Stype"
          }
        },
        "nonNegativeInteger": {
          "items": {
            "$ref": "#/definitions/nonNegativeInteger_Stype"
          }
        },
        "nonPositiveInteger": {
          "items": {
            "$ref": "#/definitions/nonPositiveInteger_Stype"
          }
        },
        "positiveInteger": {
          "items": {
            "$ref": "#/definitions/positiveInteger_Stype"
          }
        },
        "short": {
          "items": {
            "$ref": "#/definitions/short_Stype"
          }
        },
        "string": {
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "time": {
          "items": {
            "$ref": "#/definitions/time_Stype"
          }
        },
        "unsignedByte": {
          "items": {
            "$ref": "#/definitions/unsignedByte_Stype"
          }
        },
        "unsignedInt": {
          "items": {
            "$ref": "#/definitions/unsignedInt_Stype"
          }
        },
        "unsignedLong": {
          "items": {
            "$ref": "#/definitions/unsignedLong_Stype"
          }
        },
        "unsignedShort": {
          "items": {
            "$ref": "#/definitions/unsignedShort_Stype"
          }
        },
        "XML": {
          "items": {
            "$ref": "#/definitions/XML_Stype"
          }
        },
        "yearMonthDuration": {
          "items": {
            "$ref": "#/definitions/yearMonthDuration_Stype"
          }
        }
      }
    },
    "ScriptCodeBaseType": {
      "description": "Programming code or pseudocode that describes a calculation. THe code returns a value of the data type required by the parent Response field. To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent. It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs. The @ type attribute may be used to distinguish between them. An Extension may be used instead of or along with an Expression and Parameters list. Expressions may populate Responses that are set to @readOnly = \"true\" to ensure that all responses are calculated and not latered by the user. Alternatively, the user may change a value created by (or instead of) the Expression.",
      "type": "object"
    },
    "ScriptCodeBoolType": {
      "description": "Programming code or pseudocode that describes a calculation. The code returns a value of the data type required by the parent Response field. To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent. It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs. The @ type attribute may be used to distinguish between them. An Extension may be used instead of or along with an Expression and Parameters list. Expressions may populate Responses that are set to @readOnly = \"true\" to ensure that all responses are calculated and not latered by the user. Alternatively, the user may change a value created by (or instead of) the Expression.",
      "type": "object"
    },
    "ScriptCodeAnyType": {
      "description": "Programming code or pseudocode that describes a calculation. THe code returns a value of the data type required by the parent Response field. To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent. It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs. The @ type attribute may be used to distinguish between them. An Extension may be used instead of or along with an Expression and Parameters list. Expressions may populate Responses that are set to @readOnly = \"true\" to ensure that all responses are calculated and not latered by the user. Alternatively, the user may change a value created by (or instead of) the Expression.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "CallFuncBaseType": {
      "description": "Function or web service that returns a string value.",
      "type": "object"
    },
    "CallFuncType": {
      "description": "Function or web service that returns a string value.",
      "type": "object"
    },
    "CallFuncBoolType": {
      "description": "Function or web service that returns a string value.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "FunctionURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "LocalFunctionName": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "Security": {
          "$ref": "#/definitions/RichTextType"
        },
        "ParameterRef": {
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        },
        "ListItemParameterRef": {
          "items": {
            "$ref": "#/definitions/ListItemParameterType"
          }
        },
        "ParameterValue": {
          "items": {
            "$ref": "#/definitions/ParameterValueType"
          }
        }
      }
    },
    "FuncBoolBaseType": {
      "description": "Function or web service that returns a Boolean value. Items that inherit from this class must test the result for being a Boolean true/false value or null.",
      "type": "object"
    },
    "toggleType": {
      "type": "string",
      "enum": [
        "true",
        "false",
        "toggle",
        "ignore"
      ]
    },
    "ChildElementsGroup": {
      "type": "object"
    },
    "ActionElseType": {
      "type": "object"
    },
    "DataElementType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Section": {
          "items": {
            "$ref": "#/definitions/SectionItemType"
          }
        },
        "Question": {
          "items": {
            "$ref": "#/definitions/QuestionItemType"
          }
        },
        "DisplayedItem": {
          "items": {
            "$ref": "#/definitions/DisplayedType"
          }
        },
        "ButtonAction": {
          "items": {
            "$ref": "#/definitions/ButtonItemType"
          }
        },
        "InjectForm": {
          "items": {
            "$ref": "#/definitions/InjectFormType"
          }
        }
      }
    },
    "FormDesignType": {
      "description": "Start here. This is the top level of the SDCFormDesign object model.\r \t\t\t\tIt represents the definition for the information content of a single data-entry\r \t\t\t\tform.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "BeforeLoadForm": {
          "$ref": "#/definitions/EventType"
        },
        "BeforeLoadData": {
          "$ref": "#/definitions/EventType"
        },
        "BeforeShowForm": {
          "$ref": "#/definitions/EventType"
        },
        "BeforeDataSubmit": {
          "$ref": "#/definitions/EventType"
        },
        "BeforeCloseForm": {
          "$ref": "#/definitions/EventType"
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "Header": {
          "$ref": "#/definitions/SectionItemType"
        },
        "Body": {
          "$ref": "#/definitions/SectionItemType"
        },
        "Footer": {
          "$ref": "#/definitions/SectionItemType"
        },
        "Rules": {
          "$ref": "#/definitions/RulesType"
        }
      },
      "required": [
        "Body"
      ]
    },
    "ChildItemsType": {
      "description": "ChildItems have descendants that are of type DisplayedType. They may\r \t\t\t\tinclude primary items of type SectionType, QuestionType, InjectFormType,\r \t\t\t\tDisplayedType and ButtonType, in any order. The ChildItem separates new child\r \t\t\t\tprimary items from elements and attributes that are sub-parts of the parent primary\r \t\t\t\titem.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Section": {
          "items": {
            "$ref": "#/definitions/SectionItemType"
          }
        },
        "Question": {
          "items": {
            "$ref": "#/definitions/QuestionItemType"
          }
        },
        "DisplayedItem": {
          "items": {
            "$ref": "#/definitions/DisplayedType"
          }
        },
        "ButtonAction": {
          "items": {
            "$ref": "#/definitions/ButtonItemType"
          }
        },
        "InjectForm": {
          "items": {
            "$ref": "#/definitions/InjectFormType"
          }
        }
      }
    },
    "InjectFormType": {
      "description": "CHANGED: This type represents a form or portion of a form that is\r \t\t\t\timported into the current form at a specific location. It allows the composition of\r \t\t\t\tforms from other forms or parts of other forms. In practice, using an injected\r \t\t\t\tsection will requiresome or all of the injected FormDesignXML to be injected under\r \t\t\t\tthis the InjectForm element. For that reason, the schema supports those elements to\r \t\t\t\tappear inline. However, in a \"raw\" form (not yet filled out), the FormDesign element\r \t\t\t\twould generally be empty; only the top-level InjectFormType attributes would be used\r \t\t\t\tto point to the parts to be later injected. Form parts to be injected are specified\r \t\t\t\tby packageID, not FormID. This allows an injected form to be assocaited with helper\r \t\t\t\tfiles, or to return previosuly completed form parts containing responses.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Section": {
          "items": {
            "$ref": "#/definitions/SectionItemType"
          }
        },
        "Question": {
          "items": {
            "$ref": "#/definitions/QuestionItemType"
          }
        },
        "FormDesign": {
          "items": {
            "$ref": "#/definitions/FormDesignType"
          }
        }
      }
    },
    "LookupEndPointType": {
      "description": "LookupEndPointType represents list items that are derived from a web\r \t\t\t\tservice call of some type, instead of an explicit set of ListItem nodes specified in\r \t\t\t\tthe FormDesign XML. The endpoint must return a list separated into individual list\r \t\t\t\titems by the @colTextDelimiter value specified in the parent\r \t\t\t\tListFieldType.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "FunctionURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "LocalFunctionName": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "Security": {
          "$ref": "#/definitions/RichTextType"
        },
        "ParameterRef": {
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        },
        "ListItemParameterRef": {
          "items": {
            "$ref": "#/definitions/ListItemParameterType"
          }
        },
        "ParameterValue": {
          "items": {
            "$ref": "#/definitions/ParameterValueType"
          }
        },
        "ConditionalActions": {
          "$ref": "#/definitions/PredActionType"
        },
        "ResponseValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        }
      }
    },
    "ListItemType": {
      "description": "ListItem elements represent answer choices that may appear under a\r \t\t\t\tQuestion.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "ListItemResponseField": {
          "$ref": "#/definitions/ListItemResponseFieldType"
        },
        "OnSelect": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnDeselect": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "SelectIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "DeselectIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "ChildItems": {
          "items": {
            "$ref": "#/definitions/ChildItemsType"
          }
        }
      }
    },
    "ListItemBaseType": {
      "description": "This base element is the foundation for ListItems, but does not\r \t\t\t\tinclude the MainItems sub-group under each ListItem.",
      "type": "object"
    },
    "ListType": {
      "description": "This type represents a list of specified answer choices. CHANGED\r \t\t\t\t9/20/2016: Fix for serialization error which aggregated all DisplayedItems at the\r \t\t\t\ttop of the ListItems. A Schematron (or similar validation tool) will be required to\r \t\t\t\tensure that at least 2 ListItems are present for single-select questions, and one\r \t\t\t\tListItem for multi-select questions.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "DisplayedItem": {
          "items": {
            "$ref": "#/definitions/DisplayedType"
          }
        },
        "ListItem": {
          "items": {
            "$ref": "#/definitions/ListItemType"
          }
        }
      }
    },
    "ListFieldType": {
      "description": "ListField is a grouper for list-like answer choices, which may be\r \t\t\t\tderived from either a set of answer choice lists (a List composed of ListItems) or\r \t\t\t\tor a list obtained from a LookupEndpoint URI.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "ListHeaderText": {
          "$ref": "#/definitions/RichTextType"
        },
        "DefaultCodeSystem": {
          "$ref": "#/definitions/CodeSystemType"
        },
        "List": {
          "items": {
            "$ref": "#/definitions/ListType"
          }
        },
        "LookupEndPoint": {
          "items": {
            "$ref": "#/definitions/LookupEndPointType"
          }
        },
        "IllegalListItemPairings": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredSelectionTestType"
          }
        },
        "IllegalCoSelectedListItems": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredSingleSelectionSetsType"
          }
        },
        "AfterChange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        }
      }
    },
    "ResponseFieldType": {
      "description": "This type is a template for a data entry field that accepts entries\r \t\t\t\t(responses or answers) of any data type, including text, numbers, dates, and Base 64\r \t\t\t\t- encoded blobs (images, sounds, video, other binary formats, etc.). This type\r \t\t\t\tcannot contain ListItems, but it may be a child of a Question or a\r \t\t\t\tListItem.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Response": {
          "$ref": "#/definitions/DataTypes_DEType"
        },
        "CallSetValue": {
          "items": {
            "$ref": "#/definitions/CallFuncActionType"
          }
        },
        "SetValue": {
          "items": {
            "$ref": "#/definitions/ScriptCodeAnyType"
          }
        },
        "TextAfterResponse": {
          "$ref": "#/definitions/RichTextType"
        },
        "ResponseUnits": {
          "$ref": "#/definitions/UnitsType"
        },
        "AfterChange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        }
      },
      "required": [
        "Response"
      ]
    },
    "ListItemResponseFieldType": {
      "description": "This type represents a place to store a fill-in response associated\r \t\t\t\tdirectly with a selected ListItem. The response may be optional or\r \t\t\t\trequired.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Response": {
          "$ref": "#/definitions/DataTypes_DEType"
        },
        "CallSetValue": {
          "items": {
            "$ref": "#/definitions/CallFuncActionType"
          }
        },
        "SetValue": {
          "items": {
            "$ref": "#/definitions/ScriptCodeAnyType"
          }
        },
        "TextAfterResponse": {
          "$ref": "#/definitions/RichTextType"
        },
        "ResponseUnits": {
          "$ref": "#/definitions/UnitsType"
        },
        "AfterChange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        }
      },
      "required": [
        "Response"
      ]
    },
    "ButtonItemType": {
      "description": "The ButtonItem type represents a visual area for a user to click, and\r \t\t\t\tthe click triggers a piece of \"Action\" code to run inside the form. The ButtonAction\r \t\t\t\tobject may be represented with a visible button object, or some other type of visual\r \t\t\t\tparadigm. Other types of actions (e.g. key presses in a text field) may be handled\r \t\t\t\twith the form framework's event model.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "OnClick": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        }
      }
    },
    "SectionItemType": {
      "description": "The Section is a grouper for all other types of objects. It may have a\r \t\t\t\tdistinctive visual display (e.g. a box containing other displayed objects), and it\r \t\t\t\tmay be used to treat Section descendants as a unit for special handling, such as\r \t\t\t\thiding and showing.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "ChildItems": {
          "items": {
            "$ref": "#/definitions/ChildItemsType"
          }
        }
      }
    },
    "SectionBaseType": {
      "description": "This base item is the same as the SectionItemType, except it lacks the\r \t\t\t\trecursion created by the inclusion of MainItems sub-group.",
      "type": "object"
    },
    "QuestionItemType": {
      "description": "Represents questions. Parent items may be Section, Question, and\r \t\t\t\tListItem.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "ResponseField": {
          "items": {
            "$ref": "#/definitions/ResponseFieldType"
          }
        },
        "ListField": {
          "items": {
            "$ref": "#/definitions/ListFieldType"
          }
        },
        "ChildItems": {
          "items": {
            "$ref": "#/definitions/ChildItemsType"
          }
        }
      }
    },
    "QuestionItemBaseType": {
      "description": "Represents questions. Parent items may be Section, Question, and\r \t\t\t\tListItem.",
      "type": "object"
    },
    "RepeatingType": {
      "description": "This type presents any display objects that may be repeated based upon\r \t\t\t\ton the user's interaction with the form objects. Items derived from this type\r \t\t\t\tinclude Sections and Questions.",
      "type": "object"
    },
    "DisplayedType": {
      "description": "This type represents any object that is designed to have a visual\r \t\t\t\tpresence on a form, e.g., Sections, Questions, ListItems, Notes and Blobs. (Other\r \t\t\t\titems not inheriting this type may use an optional styleClass\r \t\t\t\tattribute.)",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "BlobContent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlobType"
          }
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "CodedValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CodingType"
          }
        },
        "OnEnter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnExit": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventType"
          }
        },
        "OnEvent": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OnEventType"
          }
        },
        "ActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        },
        "DeActivateIf": {
          "$ref": "#/definitions/PredGuardType"
        }
      }
    },
    "EventType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "AttributeEval": {
          "items": {
            "$ref": "#/definitions/AttributeEvalActionType"
          }
        },
        "ScriptBoolFunc": {
          "items": {
            "$ref": "#/definitions/ScriptBoolFuncActionType"
          }
        },
        "CallBoolFunction": {
          "items": {
            "$ref": "#/definitions/CallFuncBoolActionType"
          }
        },
        "MultiSelections": {
          "items": {
            "$ref": "#/definitions/MultiSelectionsActionType"
          }
        },
        "SelectionSets": {
          "items": {
            "$ref": "#/definitions/SelectionSetsActionType"
          }
        },
        "SelectionTest": {
          "items": {
            "$ref": "#/definitions/SelectionTestActionType"
          }
        },
        "Group": {
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        },
        "SelectMatchingListItems": {
          "items": {
            "$ref": "#/definitions/RuleSelectMatchingListItemsType"
          }
        },
        "Actions": {
          "$ref": "#/definitions/ActionsType"
        },
        "Else": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        }
      }
    },
    "OnEventType": {
      "description": "Add a custom event handler to a form item such as a question, section\r \t\t\t\tor list item.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "AttributeEval": {
          "items": {
            "$ref": "#/definitions/AttributeEvalActionType"
          }
        },
        "ScriptBoolFunc": {
          "items": {
            "$ref": "#/definitions/ScriptBoolFuncActionType"
          }
        },
        "CallBoolFunction": {
          "items": {
            "$ref": "#/definitions/CallFuncBoolActionType"
          }
        },
        "MultiSelections": {
          "items": {
            "$ref": "#/definitions/MultiSelectionsActionType"
          }
        },
        "SelectionSets": {
          "items": {
            "$ref": "#/definitions/SelectionSetsActionType"
          }
        },
        "SelectionTest": {
          "items": {
            "$ref": "#/definitions/SelectionTestActionType"
          }
        },
        "Group": {
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        },
        "SelectMatchingListItems": {
          "items": {
            "$ref": "#/definitions/RuleSelectMatchingListItemsType"
          }
        },
        "Actions": {
          "$ref": "#/definitions/ActionsType"
        },
        "Else": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        }
      }
    },
    "ActSetAttributeType": {
      "description": "This type is used to act upon the value of common item attributes. If\r \t\t\t\tan \"act\" attribute (a type with the \"act\" prefix) has no value assigned, it is\r \t\t\t\tignored. If it has a value, then that attribute on the target item(s) assume(s) that\r \t\t\t\tstated value when an attached Boolean condition evaluates to true. The attached\r \t\t\t\tcondition may be an \"If\" statement or any expression that evaluates to a Boolean\r \t\t\t\tvalue.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "ActSetAttrValueScriptType": {
      "description": "This type is used to act upon the value of common item properties. If\r \t\t\t\tan \"act\" property (a property with the \"act\" prefix) has no value assigned, it is\r \t\t\t\tignored. If it has a value, then that property on the target item(s) assume(s) that\r \t\t\t\tstated value when an attached Boolean condition evaluates to true. The attached\r \t\t\t\tcondition may be an \"If\" statement or any expression that evaluates to a Boolean\r \t\t\t\tvalue.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Target": {
          "$ref": "#/definitions/ItemNameAttributeType"
        }
      },
      "required": [
        "Target"
      ]
    },
    "ActSetBoolAttributeValueCode": {
      "description": "Sets the value of any named attribute. However, it is primarily\r \t\t\t\tdesigned for Response element(s) on a Question or ListItem. The value may be\r \t\t\t\tdetermined by a literal value with a defined data type, the value at another named\r \t\t\t\tResponse item, an expression written in a specified scripting or programming\r \t\t\t\tlanguage, or the value of a named code listed in the same\r \t\t\t\ttemplate.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "ActShowMessageType": {
      "description": "Display a message to the form user, triggered by activity within the\r \t\t\t\tform.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Message": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RichTextType"
          },
          "minItems": 1
        }
      }
    },
    "ActShowFormType": {
      "description": "Show an external form to interact with the user.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "ActSaveResponsesType": {
      "description": "Save the form's responses to the default persistance layer(s). The\r \t\t\t\tdefault format is SDCSubmitForm, but other formats may be defined and\r \t\t\t\tused.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "MessageText": {
          "$ref": "#/definitions/RichTextType"
        }
      },
      "required": [
        "MessageText"
      ]
    },
    "ActShowReportType": {
      "description": "Show a stored report. The following parameters may be used: reportID:\r \t\t\t\tindicator of a report definition in SDC format. packageID: retrieve report as a\r \t\t\t\tpackage with ancillary information. reportInstanceGUID: retreive 1 or more report\r \t\t\t\tversions by using a report instance GUID. This may be used in conjunctions with a\r \t\t\t\tpackageID. reportInstanceVersionGUID: retrieve a single version of a report\r \t\t\t\trepresenting the state of a report when it was saved. This may be used in\r \t\t\t\tconjunctions with a packageID.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "ActPreviewReportType": {
      "description": "Show a report preview, based on data in the current form. The\r \t\t\t\tfollowing parameter may be used: reportID: points to a report definition in SDC\r \t\t\t\tformat.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "ActSendReportType": {
      "description": "Send a report to an endpoint, via email, fax or web service. The\r \t\t\t\tdefault report will be transmittted in SDCSubmitForm format, but may adopt a custom\r \t\t\t\treport type",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Email": {
          "items": {
            "$ref": "#/definitions/EmailAddressType"
          }
        },
        "Fax": {
          "items": {
            "$ref": "#/definitions/PhoneNumberType"
          }
        },
        "WebService": {
          "items": {
            "$ref": "#/definitions/CallFuncActionType"
          }
        }
      }
    },
    "ActSendMessageType": {
      "description": "Send a message to any endpoint. Messages may include alerts of various\r \t\t\t\ttypes. The default datatype for messages is string.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "RichText": {
          "$ref": "#/definitions/HTML_Stype"
        },
        "Email": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EmailAddressType"
            },
            "minItems": 1
          }
        },
        "Fax": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/PhoneNumberType"
            },
            "minItems": 1
          }
        },
        "WebService": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/CallFuncActionType"
            },
            "minItems": 1
          }
        }
      },
      "required": [
        "RichText"
      ]
    },
    "ActValidateFormType": {
      "description": "Test the data in the form for proper data types, rule integrity, and\r \t\t\t\tcompleteness of required questions.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "ValidationWebService": {
          "$ref": "#/definitions/CallFuncActionType"
        }
      }
    },
    "ActInjectType": {
      "description": "Inject a form or part of a form at the specified location. The\r \t\t\t\tinjected section may come from the current form.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Section": {
          "items": {
            "$ref": "#/definitions/SectionItemType"
          }
        },
        "Question": {
          "items": {
            "$ref": "#/definitions/QuestionItemType"
          }
        },
        "FormDesign": {
          "items": {
            "$ref": "#/definitions/FormDesignType"
          }
        }
      }
    },
    "ActAddCodeType": {
      "description": "Add all or part of a coding section to the designated target\r \t\t\t\tsite.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Code": {
          "$ref": "#/definitions/CodingType"
        }
      },
      "required": [
        "Code"
      ]
    },
    "ActActionType": {
      "description": "Add a custom action, not defined in the basic SDC\r \t\t\t\tSchemas.",
      "type": "object"
    },
    "ActionsType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Action": {
          "items": {
            "$ref": "#/definitions/ActActionType"
          }
        },
        "SelectMatchingListItems": {
          "items": {
            "$ref": "#/definitions/RuleSelectMatchingListItemsType"
          }
        },
        "AddCode": {
          "items": {
            "$ref": "#/definitions/ActAddCodeType"
          }
        },
        "Inject": {
          "items": {
            "$ref": "#/definitions/ActInjectType"
          }
        },
        "ShowURL": {
          "items": {
            "$ref": "#/definitions/CallFuncActionType"
          }
        },
        "Save": {
          "items": {
            "$ref": "#/definitions/ActSaveResponsesType"
          }
        },
        "SendReport": {
          "items": {
            "$ref": "#/definitions/ActSendReportType"
          }
        },
        "SendMessage111": {
          "items": {
            "$ref": "#/definitions/ActSendMessageType"
          }
        },
        "SetAttributeValue": {
          "items": {
            "$ref": "#/definitions/ActSetAttributeType"
          }
        },
        "SetAttributeValueScript": {
          "items": {
            "$ref": "#/definitions/ActSetAttrValueScriptType"
          }
        },
        "SetBoolAttributeValueCode": {
          "items": {
            "$ref": "#/definitions/ActSetBoolAttributeValueCode"
          }
        },
        "ShowForm": {
          "items": {
            "$ref": "#/definitions/ActShowFormType"
          }
        },
        "ShowMessage": {
          "items": {
            "$ref": "#/definitions/ActShowMessageType"
          }
        },
        "ShowReport": {
          "items": {
            "$ref": "#/definitions/ActShowReportType"
          }
        },
        "PreviewReport": {
          "items": {
            "$ref": "#/definitions/ActPreviewReportType"
          }
        },
        "ValidateForm": {
          "items": {
            "$ref": "#/definitions/ActValidateFormType"
          }
        },
        "RunCode": {
          "items": {
            "$ref": "#/definitions/ScriptCodeAnyType"
          }
        },
        "CallFunction": {
          "items": {
            "$ref": "#/definitions/CallFuncActionType"
          }
        },
        "ConditionalGroupAction": {
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        }
      }
    },
    "RuleSelectMatchingListItemsType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "MatchSource": {
          "$ref": "#/definitions/ItemNameAttributeType"
        },
        "ListItemMatchTargets": {
          "$ref": "#/definitions/RuleListItemMatchTargetsType"
        }
      },
      "required": [
        "MatchSource",
        "ListItemMatchTargets"
      ]
    },
    "RuleAutoSelectType": {
      "description": "This Rule selects/unselects ListItems based on the selected status of\r \t\t\t\tother ListItems. This declarative rule determines (guards) when target ListItems\r \t\t\t\tshould be selected or unselected. The guard rule may optionally select/unselect\r \t\t\t\tmultiple target ListItems with a single rule. The target ListItem(s) to\r \t\t\t\tselect/unselect are listed in targetNameSelectList. In the simplest case, this rule\r \t\t\t\toperates as follows: A list of ListItems is provided (selectedItemWatchList). If all\r \t\t\t\tthe items in the list are selected (or unselected - see below) as specified in the\r \t\t\t\tselectedItemWatchList list, then the guard evaluates to true, and the\r \t\t\t\ttargetNameSelectList items are selected. In some cases, we may wish to watch\r \t\t\t\tunselected items in the selectedItemWatchList. This is indicated by prefixing the\r \t\t\t\tname of the watched item with a minus sign/dash (\"-\"). In some cases, we may wish to\r \t\t\t\tunselect items in the targetNameSelectList list when the selectedItemWatchList\r \t\t\t\tevaluated to true. In this case, the target item is prefixed with a dash (\"-\").",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "RuleAutoActivateType": {
      "description": "This Rule sets the activation status of Items based on the selection\r \t\t\t\tstatus of other ListItems. This declarative rule determines (guards) when target\r \t\t\t\tItems should be activated or deactivated. The rule may optionally\r \t\t\t\tactivate/deactivate multiple target items with a single rule. The target item(s) to\r \t\t\t\tactivate/deactivate are listed in targetNameList. In the simplest case, this rule\r \t\t\t\toperates as follows: A list of ListItems is provided (selectedItemWatchList). If all\r \t\t\t\tthe items in the list are selected (or unselected - see below) as specified in the\r \t\t\t\tselectedItemWatchList list, then the guard evaluates to true, and the targetNameList\r \t\t\t\titems are activated/deactivated. In some cases, we may wish to watch unselected\r \t\t\t\titems in the selectedItemWatchList. This is indicated by prefixing the name of the\r \t\t\t\twatched item with a minus sign/dash (\"-\"). In some cases, we may wish to deactivate\r \t\t\t\titems in the targetNameSelectList list when the selectedItemWatchList evaluated to\r \t\t\t\ttrue. In this case, the target item is prefixed with a dash (\"-\").",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "RuleListItemMatchTargetsType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "PredSelectionTestType": {
      "description": "This Rule specifies a set of ListItems that cannot be selected\r \t\t\t\t(@listItemNames) when a test ListItem (@testItemName) is selected. If any selection\r \t\t\t\toccurs in @listItemNames when @testItemName is selected, the rule evaluate to true.\r \t\t\t\tIn all other cases, the rule evaluates to false. Multiple selections in\r \t\t\t\t@listItemNames are acceptable as long as @testItemName is unselected, and in this\r \t\t\t\tcase, the rule evaluates to false. \"Legal\" (allowed) selections evaluate to false\r \t\t\t\t\"Illegal\" selections evaluate to true Renamed from:\r \t\t\t\tIllegalSelectionTest",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "PredSingleSelectionSetsType": {
      "description": "This Rule tests combinations of co-selected ListItems (answers). If\r \t\t\t\tmore than X items in the @listItemNames list are selected, then the result returns\r \t\t\t\tthe value of true. Otherwise it is false. X is specified in @maxSelections, and the\r \t\t\t\tdefault is 1. The most common use is to detect ListItem combinations that may not be\r \t\t\t\tselected together. In most cases, all ListItems should be children of one\r \t\t\t\tmulti-select question. Delete this: Legal (\"allowed\") selections evaluate to false\r \t\t\t\tIllegal selections evaluate to true These values can be reversed if @not is set to\r \t\t\t\ttrue Renamed from: IllegalSelectionSets",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "PredMultiSelectionSetBoolType": {
      "description": "This Rule component evaluates the @selected status of any set of\r \t\t\t\tListItems at runtime, and returns a true or false value based on the @selected\r \t\t\t\tstatus of each ListItem.",
      "type": "object"
    },
    "PredEvalAttribValuesType": {
      "description": "This Rule evaluates an arbitrary set of attribute values from any item\r \t\t\t\tand returns a Boolean summary value. In the PropertyValues condition, the contained\r \t\t\t\tBoolean attributed values are ANDed together (by default) to return a derived\r \t\t\t\tBoolean value. Default values are used if the attribute is not explicitly set to a\r \t\t\t\tvalue. For attributes without default values, omitted (null) values are ignored and\r \t\t\t\tare not used for null propagation.",
      "type": "object"
    },
    "PredAlternativesType": {
      "description": "This Rule tests if one (or more) items in a list of items has received\r \t\t\t\ta a valid user response (answer). In the simplest case, this Rule allows a user to\r \t\t\t\tanswer only one of several alternative questions (named in the @itemNames list), and\r \t\t\t\tstill save a successfully-validated form. In more complex cases, a user can be\r \t\t\t\trequired to produce a valid response to a specific minimum and maximum number of\r \t\t\t\tQuestions, Sections, ListItems or Injected parts. The minCard value on each of the\r \t\t\t\talternative items should be set to \"0\" (i.e., optional) to avoid validation\r \t\t\t\tconflicts when minCard greater than 0. The list of Item @name values is contained in\r \t\t\t\t@itemNames. The list must contain at least 2 @name values. The minimum number of\r \t\t\t\titems to answer is contained in @minAnswered (default value = 1). If there is a\r \t\t\t\tmaximum number of items to answer, the value is contained in @maxAnswered (default\r \t\t\t\tvalue = 0 meaning unlimited).",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        }
      }
    },
    "PredGuardType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "AttributeEval": {
          "items": {
            "$ref": "#/definitions/PredEvalAttribValuesType"
          }
        },
        "ScriptBoolFunc": {
          "items": {
            "$ref": "#/definitions/ScriptCodeBoolType"
          }
        },
        "CallBoolFunc": {
          "items": {
            "$ref": "#/definitions/CallFuncBoolType"
          }
        },
        "MultiSelections": {
          "items": {
            "$ref": "#/definitions/PredMultiSelectionSetBoolType"
          }
        },
        "SelectionTest": {
          "items": {
            "$ref": "#/definitions/PredSelectionTestType"
          }
        },
        "SelectionSets": {
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "not": {
                "description": "If @not=\"true\" then the logical value of the conditions of the parent element is negated; true becomes false and false becomes true.",
                "type": "boolean"
              },
              "listItemNames": {
                "description": "Set of @name references for a set ListItems, delimited by \t\t\t\t\t\t\tspaces.",
                "type": "string"
              },
              "maxSelections": {
                "description": "The maximum number of ListItems in @listItemNames that may \t\t\t\t\t\t\tbe selected at one time.",
                "type": "integer"
              },
              "allowNull": {
                "description": "True means that null values are allowed in @returnVal. This corresponds to an empty string in @val or a missing @returnVal attribute.",
                "type": "boolean"
              },
              "validationMessage": {
                "description": "Optional message that appears when the rule evaluates to true",
                "type": "string"
              },
              "returnVal": {
                "type": "boolean"
              },
              "name": {
                "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                "type": "string"
              },
              "order": {
                "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                "type": "number",
                "minimum": 0.0
              }
            },
            "required": [
              "listItemNames"
            ]
          }
        },
        "ItemAlternatives": {
          "items": {
            "$ref": "#/definitions/PredAlternativesType"
          }
        },
        "Group": {
          "items": {
            "$ref": "#/definitions/PredGuardType"
          }
        }
      }
    },
    "PredActionType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "AttributeEval": {
          "items": {
            "$ref": "#/definitions/AttributeEvalActionType"
          }
        },
        "ScriptBoolFunc": {
          "items": {
            "$ref": "#/definitions/ScriptBoolFuncActionType"
          }
        },
        "CallBoolFunction": {
          "items": {
            "$ref": "#/definitions/CallFuncBoolActionType"
          }
        },
        "MultiSelections": {
          "items": {
            "$ref": "#/definitions/MultiSelectionsActionType"
          }
        },
        "SelectionSets": {
          "items": {
            "$ref": "#/definitions/SelectionSetsActionType"
          }
        },
        "SelectionTest": {
          "items": {
            "$ref": "#/definitions/SelectionTestActionType"
          }
        },
        "Group": {
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        },
        "SelectMatchingListItems": {
          "items": {
            "$ref": "#/definitions/RuleSelectMatchingListItemsType"
          }
        },
        "Actions": {
          "$ref": "#/definitions/ActionsType"
        },
        "Else": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        }
      }
    },
    "RulesType": {
      "description": "Rules are procedures that affect form behaviour. They are usually\r \t\t\t\ttriggered by changes to the form by a form user. They may also be triggered by other\r \t\t\t\trules or changes to form metadata (e.g., change to @visible). SDC decarative form\r \t\t\t\trules consist of several types: Assertions are \"predicate\" expressions that evaulate\r \t\t\t\tto true or false, based upon the state of answers/responses or metadata within a\r \t\t\t\tform. An asserion is equivalent to the \"If\" part of an If-Then block. The\r \t\t\t\timplementation framework must assign a fucntion to handle any assertion that\r \t\t\t\tevaluates to False. Assertions are no handled by the form itself. If-Then-Else\r \t\t\t\tblocks run a \"Then\" action if the \"If block evaluated to true, and an \"Else\" block\r \t\t\t\tif the \"If\" block evaluates to false. An AutoSelection rule automatically selects an\r \t\t\t\tanswer choice (ListItem) when another answer (or set of answers) is selected or\r \t\t\t\tunselected. IllegalSelectionTest evaluates to true if a disallowed set of answer\r \t\t\t\tchoices is selected at the same time. The implementation should take an action\r \t\t\t\t(alert user, cancel inout, etc) when a true result occurs. IllegalSelection Set\r \t\t\t\trestricts combinations of co-selected ListItems (answers). In other words, only zero\r \t\t\t\tor one item in this list may be selected at a time.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Validation": {
          "$ref": "#/definitions/ValidationType"
        },
        "AutoActivation": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleAutoActivateType"
          }
        },
        "AutoSelection": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleAutoSelectType"
          }
        },
        "SelectMatchingListItems": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleSelectMatchingListItemsType"
          }
        },
        "ConditionalActions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        },
        "ScriptedRule": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScriptCodeAnyType"
          }
        },
        "ExternalRule": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CallFuncActionType"
          }
        }
      }
    },
    "CallFuncActionType": {
      "description": "Function or web service that returns a string\r \t\t\t\tvalue.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "FunctionURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "LocalFunctionName": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "Security": {
          "$ref": "#/definitions/RichTextType"
        },
        "ParameterRef": {
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        },
        "ListItemParameterRef": {
          "items": {
            "$ref": "#/definitions/ListItemParameterType"
          }
        },
        "ParameterValue": {
          "items": {
            "$ref": "#/definitions/ParameterValueType"
          }
        },
        "ConditionalActions": {
          "$ref": "#/definitions/PredActionType"
        }
      }
    },
    "CallFuncBoolActionType": {
      "description": "Function or web service that returns a string\r \t\t\t\tvalue.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "FunctionURI": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "LocalFunctionName": {
          "items": {
            "$ref": "#/definitions/anyURI_Stype"
          }
        },
        "Security": {
          "$ref": "#/definitions/RichTextType"
        },
        "ParameterRef": {
          "items": {
            "$ref": "#/definitions/ParameterItemType"
          }
        },
        "ListItemParameterRef": {
          "items": {
            "$ref": "#/definitions/ListItemParameterType"
          }
        },
        "ParameterValue": {
          "items": {
            "$ref": "#/definitions/ParameterValueType"
          }
        },
        "ConditionalActions": {
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        },
        "Actions": {
          "items": {
            "$ref": "#/definitions/ActionsType"
          }
        },
        "Else": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/PredActionType"
            }
          }
        }
      }
    },
    "ScriptBoolFuncActionType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "ConditionalActions": {
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        },
        "Actions": {
          "items": {
            "$ref": "#/definitions/ActionsType"
          }
        },
        "Else": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/PredActionType"
            }
          }
        }
      }
    },
    "AttributeEvalActionType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Actions": {
          "$ref": "#/definitions/ActionsType"
        },
        "Else": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        }
      }
    },
    "MultiSelectionsActionType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Actions": {
          "$ref": "#/definitions/ActionsType"
        },
        "Else": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        }
      }
    },
    "SelectionSetsActionType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Actions": {
          "$ref": "#/definitions/ActionsType"
        },
        "Else": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        }
      }
    },
    "SelectionTestActionType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Actions": {
          "$ref": "#/definitions/ActionsType"
        },
        "Else": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PredActionType"
          }
        }
      }
    },
    "ValidationType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "SelectionTest": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "Comment": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/CommentType"
                  }
                },
                "Extension": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/ExtensionType"
                  }
                },
                "Property": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/PropertyType"
                  }
                },
                "not": {
                  "description": "If @not=\"true\" then the logical value of the conditions of the parent element is negated; true becomes false and false becomes true.",
                  "type": "boolean"
                },
                "testItemName": {
                  "description": "The ListItem that is being evaluated for the presence of \t\t\t\t\t\t\tdisallowed selections (in @listItemNames). This attributes contains the \t\t\t\t\t\t\t@name of one ListItem.",
                  "type": "string"
                },
                "listItemNames": {
                  "description": "Set of @name references for a set ListItems, delimited by \t\t\t\t\t\t\tspaces.",
                  "type": "string"
                },
                "maxSelections": {
                  "description": "The maximum number of ListItems in @listItemNames that may \t\t\t\t\t\t\tbe selected at one time.",
                  "type": "integer"
                },
                "allowNull": {
                  "description": "True means that null values are allowed in @returnVal. This corresponds to an empty string in @val or a missing @returnVal attribute.",
                  "type": "boolean"
                },
                "validationMessage": {
                  "description": "Optional message that appears when the rule evaluates to true",
                  "type": "string"
                },
                "returnVal": {
                  "type": "boolean"
                },
                "name": {
                  "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                  "type": "string"
                },
                "type": {
                  "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                  "type": "string"
                },
                "styleClass": {
                  "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                  "type": "string"
                },
                "order": {
                  "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                  "type": "number",
                  "minimum": 0.0
                }
              },
              "required": [
                "testItemName",
                "listItemNames"
              ]
            }
          }
        },
        "SelectionSets": {
          "items": {
            "type": "array",
            "items": {
              "type": "object"
            }
          }
        },
        "ItemAlternatives": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/PredAlternativesType"
            }
          }
        }
      }
    },
    "ExtensionType": {
      "description": "Similar to the Schema type xs:anyType, but requires strict validation, and includes optional baseAttributes. Developer will need to declare a namespace and provide a Schema to validate the contents.",
      "type": "object"
    },
    "BaseType": {
      "type": "object",
      "properties": {
        "name": {
          "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
          "type": "object"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
          "type": "object"
        },
        "styleClass": {
          "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
          "type": "object"
        },
        "order": {
          "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
          "type": "object"
        }
      }
    },
    "CommentType": {
      "type": "object"
    },
    "anyType_DEtype": {
      "type": "object"
    },
    "anyURI_DEtype": {
      "type": "object"
    },
    "base64Binary_DEtype": {
      "type": "object"
    },
    "boolean_DEtype": {
      "type": "object"
    },
    "byte_DEtype": {
      "type": "object"
    },
    "date_DEtype": {
      "type": "object"
    },
    "dateTime_DEtype": {
      "type": "object"
    },
    "dateTimeStamp_DEtype": {
      "type": "object"
    },
    "dayTimeDuration_DEtype": {
      "type": "object"
    },
    "decimal_DEtype": {
      "type": "object"
    },
    "double_DEtype": {
      "type": "object"
    },
    "duration_DEtype": {
      "type": "object"
    },
    "float_DEtype": {
      "type": "object"
    },
    "gDay_DEtype": {
      "type": "object"
    },
    "gMonth_DEtype": {
      "type": "object"
    },
    "gMonthDay_DEtype": {
      "type": "object"
    },
    "gYear_DEtype": {
      "type": "object"
    },
    "gYearMonth_DEtype": {
      "type": "object"
    },
    "hexBinary_DEtype": {
      "type": "object"
    },
    "HTML_DEtype": {
      "type": "object"
    },
    "int_DEtype": {
      "type": "object"
    },
    "integer_DEtype": {
      "type": "object"
    },
    "long_DEtype": {
      "type": "object"
    },
    "negativeInteger_DEtype": {
      "type": "object"
    },
    "nonNegativeInteger_DEtype": {
      "type": "object"
    },
    "nonPositiveInteger_DEtype": {
      "type": "object"
    },
    "positiveInteger_DEtype": {
      "type": "object"
    },
    "short_DEtype": {
      "type": "object"
    },
    "string_DEtype": {
      "type": "object"
    },
    "time_DEtype": {
      "type": "object"
    },
    "unsignedByte_DEtype": {
      "type": "object"
    },
    "unsignedInt_DEtype": {
      "type": "object"
    },
    "unsignedLong_DEtype": {
      "type": "object"
    },
    "unsignedShort_DEtype": {
      "type": "object"
    },
    "XML_DEtype": {
      "type": "object"
    },
    "yearMonthDuration_DEtype": {
      "type": "object"
    },
    "anyURI_Stype": {
      "type": "object"
    },
    "base64Binary_Stype": {
      "type": "object"
    },
    "boolean_Stype": {
      "type": "object"
    },
    "byte_Stype": {
      "type": "object"
    },
    "date_Stype": {
      "type": "object"
    },
    "dateTime_Stype": {
      "type": "object"
    },
    "dateTimeStamp_Stype": {
      "type": "object"
    },
    "dayTimeDuration_Stype": {
      "type": "object"
    },
    "decimal_Stype": {
      "type": "object"
    },
    "double_Stype": {
      "type": "object"
    },
    "duration_Stype": {
      "type": "object"
    },
    "float_Stype": {
      "type": "object"
    },
    "gDay_Stype": {
      "type": "object"
    },
    "gMonth_Stype": {
      "type": "object"
    },
    "gMonthDay_Stype": {
      "type": "object"
    },
    "gYear_Stype": {
      "type": "object"
    },
    "gYearMonth_Stype": {
      "type": "object"
    },
    "hexBinary_Stype": {
      "type": "object"
    },
    "HTML_Stype": {
      "type": "object"
    },
    "int_Stype": {
      "type": "object"
    },
    "integer_Stype": {
      "type": "object"
    },
    "long_Stype": {
      "type": "object"
    },
    "negativeInteger_Stype": {
      "type": "object"
    },
    "nonNegativeInteger_Stype": {
      "type": "object"
    },
    "nonPositiveInteger_Stype": {
      "type": "object"
    },
    "positiveInteger_Stype": {
      "type": "object"
    },
    "short_Stype": {
      "type": "object"
    },
    "string_Stype": {
      "type": "object"
    },
    "time_Stype": {
      "type": "object"
    },
    "unsignedByte_Stype": {
      "type": "object"
    },
    "unsignedInt_Stype": {
      "type": "object"
    },
    "unsignedLong_Stype": {
      "type": "object"
    },
    "unsignedShort_Stype": {
      "type": "object"
    },
    "XML_Stype": {
      "type": "object"
    },
    "yearMonthDuration_Stype": {
      "type": "object"
    },
    "X_NumericConstantsType111": {
      "type": "object",
      "properties": {
        "constant": {
          "type": "object"
        }
      }
    },
    "URI_Atype": {
      "type": "string",
      "minLength": 1
    },
    "URL_Atype": {
      "type": "string",
      "minLength": 1
    },
    "DataTypeNumeric_StypeEnum": {
      "type": "string",
      "enum": [
        "byte",
        "decimal",
        "double",
        "float",
        "hexbinary",
        "int",
        "integer",
        "long",
        "negativeInteger",
        "nonNegativeInteger",
        "nonPositiveInteger",
        "positiveInteger",
        "short",
        "unsignedByte",
        "unsignedInt",
        "unsignedLong",
        "unsignedShort"
      ]
    },
    "DataTypeInteger_StypeEnum": {
      "type": "string",
      "enum": [
        "byte",
        "int",
        "integer",
        "long",
        "negativeInteger",
        "nonNegativeInteger",
        "nonPositiveInteger",
        "positiveInteger",
        "short",
        "unsignedByte",
        "unsignedInt",
        "unsignedLong",
        "unsignedShort"
      ]
    },
    "DataTypeDateTime_StypeEnum": {
      "type": "string",
      "enum": [
        "dateTime",
        "duration",
        "gMonthDay",
        "gYear",
        "gYearMonth",
        "time",
        "yearMonthDuration",
        "unsignedShort"
      ]
    },
    "DataTypeString_StypeEnum": {
      "type": "string",
      "enum": [
        "string"
      ]
    },
    "DataTypeBoolean_StypeEnum": {
      "type": "string",
      "enum": [
        "boolean"
      ]
    },
    "DataTypeCustomClass_StypeEnum": {
      "type": "object",
      "pattern": "\\c+",
      "enum": [
        "customClassName"
      ]
    },
    "DataTypeAll_StypeEnum": {},
    "TemplateAdminType": {
      "description": "Contains information about a registered package, including a description of the package contents and purpose (PackageDescription), information about the registry that contains the package XML (RegistryData), and information about the package file characteristics (TemplateFile).",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "PackageDescription": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RichTextType"
          },
          "minItems": 1
        },
        "RegistryData": {
          "$ref": "#/definitions/RegistryType"
        },
        "TemplateFile": {
          "$ref": "#/definitions/FileType"
        },
        "DigitalSignature": {
          "type": "array",
          "items": {
            "description": "NEW",
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "PackageSignature": {
                "description": "The signature derives a hash from the entire contents of the package, including the package element and all its attributes, as well as all sub-elements. Before creating the hash, the complete content of the SignatureProperties element is concatenated to the package contents.",
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "val": {
                    "type": "string"
                  }
                }
              },
              "SignatureProperties": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "Comment": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/CommentType"
                    }
                  },
                  "Extension": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/ExtensionType"
                    }
                  },
                  "Property": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/PropertyType"
                    }
                  },
                  "Signer": {
                    "$ref": "#/definitions/ContactType"
                  },
                  "SignerPublicKeyCertificate": {
                    "description": "This certificate is a structured document in ASN.1 format, that is created by a certificate authority (CA) to verify that certifiacte owner (the signer) has registered his/her/its identity with the CA. The certificate contains information about the signer and the CA, and also contains the public key of the signer. The signer's public key (obtained from the certificate) may be used to verify or decrypt any document signed by the signer.  The signer's certificate is signed with the CA's public key, and thus the CA's public key may be used to verify the validity of the signer's certificate. The CA's public key can be stored locally or may be obtained directly from the CA's own certificate. A long list of CA certificates is provided with the operating system software of most systems.   Software to verify signatures and certificates and decrypt documents is provided with most operating systems and most programming languages.",
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "val": {
                        "type": "string"
                      }
                    }
                  },
                  "SignatureReason": {
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "val": {
                        "type": "string"
                      }
                    }
                  },
                  "SignatureDateTimeStamp": {
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "val": {
                        "type": "string"
                      }
                    }
                  },
                  "X_CertificateAuthority": {
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "val": {
                        "type": "string"
                      }
                    }
                  },
                  "X_SignerPublicKey": {
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "val": {
                        "type": "string"
                      }
                    }
                  },
                  "X_SignatureAlgorithm": {
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "val": {
                        "type": "string"
                      }
                    }
                  },
                  "Image": {
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "val": {
                        "type": "string"
                      }
                    }
                  },
                  "name": {
                    "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                    "type": "string"
                  },
                  "type": {
                    "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                    "type": "string"
                  },
                  "styleClass": {
                    "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                    "type": "string"
                  },
                  "order": {
                    "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                    "type": "number",
                    "minimum": 0.0
                  }
                },
                "required": [
                  "Signer",
                  "SignerPublicKeyCertificate",
                  "SignatureReason",
                  "SignatureDateTimeStamp"
                ]
              },
              "name": {
                "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                "type": "string"
              },
              "order": {
                "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                "type": "number",
                "minimum": 0.0
              }
            },
            "required": [
              "PackageSignature",
              "SignatureProperties"
            ]
          }
        }
      },
      "required": [
        "TemplateFile"
      ]
    },
    "RegistryType": {
      "description": "This type provides data about the current and original registries that host the template or package, and also provides information about the status of the template/package within the current registry.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "OriginalRegistry": {
          "$ref": "#/definitions/RegistrySummaryType"
        },
        "CurrentRegistry": {
          "$ref": "#/definitions/RegistrySummaryType"
        },
        "RegistrationStatus": {
          "$ref": "#/definitions/RegisteredItemType"
        }
      },
      "required": [
        "CurrentRegistry"
      ]
    },
    "RegistrySummaryType": {
      "description": "This type provides a structure to record information about a registry.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "RegistryName": {
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "Contact": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ContactType"
            }
          }
        },
        "ReferenceStandardIdentifier": {
          "items": {
            "$ref": "#/definitions/string_Stype"
          }
        },
        "ServiceLevelAgreement": {
          "items": {
            "$ref": "#/definitions/FileType"
          }
        },
        "RegistryPurpose": {
          "items": {
            "$ref": "#/definitions/FileType"
          }
        },
        "Manual": {
          "items": {
            "$ref": "#/definitions/FileType"
          }
        },
        "RegistryInterface": {
          "items": {
            "$ref": "#/definitions/InterfaceType"
          }
        }
      }
    },
    "RegisteredItemType": {
      "description": "This type provides a structure to record information about a file, template or package stored in a registry.",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "RegisteredItemDescription": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RichTextType"
          }
        },
        "State": {
          "$ref": "#/definitions/RegisteredItemStateType"
        },
        "Contact": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContactType"
          }
        },
        "ReferenceDocument": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FileType"
          }
        }
      }
    },
    "RegisteredItemStateType": {
      "description": "This type provides a structure to record status information about a file, template or package stored in a registry.",
      "type": "object"
    },
    "InterfaceType": {
      "description": "This type provides information about an Applications Programming Interface (API)",
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Identifer": {
          "$ref": "#/definitions/string_Stype"
        },
        "InterfaceName": {
          "$ref": "#/definitions/string_Stype"
        },
        "Description": {
          "$ref": "#/definitions/string_Stype"
        },
        "URL": {
          "$ref": "#/definitions/string_Stype"
        },
        "Version": {
          "$ref": "#/definitions/string_Stype"
        },
        "Fields": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "Field": {
              "type": "array",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "Comment": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/CommentType"
                    }
                  },
                  "Extension": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/ExtensionType"
                    }
                  },
                  "Property": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/PropertyType"
                    }
                  },
                  "Getter": {
                    "$ref": "#/definitions/string_Stype"
                  },
                  "Setter": {
                    "$ref": "#/definitions/string_Stype"
                  },
                  "Action": {
                    "$ref": "#/definitions/string_Stype"
                  },
                  "name": {
                    "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                    "type": "string"
                  },
                  "type": {
                    "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                    "type": "string"
                  },
                  "styleClass": {
                    "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                    "type": "string"
                  },
                  "order": {
                    "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                    "type": "number",
                    "minimum": 0.0
                  }
                }
              },
              "minItems": 1
            },
            "name": {
              "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
              "type": "string"
            },
            "type": {
              "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
              "type": "string"
            },
            "styleClass": {
              "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
              "type": "string"
            },
            "order": {
              "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
              "type": "number",
              "minimum": 0.0
            }
          }
        },
        "Documentation": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "File": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/FileType"
              },
              "minItems": 1
            },
            "name": {
              "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
              "type": "string"
            },
            "type": {
              "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
              "type": "string"
            },
            "styleClass": {
              "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
              "type": "string"
            },
            "order": {
              "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
              "type": "number",
              "minimum": 0.0
            }
          }
        }
      }
    },
    "BasePackageType": {
      "type": "object",
      "properties": {
        "packageID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "pkgTitle": {
          "description": "NEW Feb 2019",
          "type": "string"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "filename": {
          "description": "NEW: filename to use when the current package instance is saved as a file.   For package containing responses, the filename may include the pkgInstanceVersionURI,   but the naming convention may be use-case-specific.",
          "type": "string"
        },
        "basedOnURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "lineage": {
          "description": "NEW: A text identifier that is used to group multiple versions of a single package. The lineage is constant for all versions of a single kind of package.   When appended to @baseURI, it can be used to retrieve all versions of one particular package.",
          "type": "string"
        },
        "version": {
          "description": "NEW: @version contains the version text for the current package. It is designed to be used in conjunction with @baseURI and @lineage.",
          "type": "string"
        },
        "fullURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "instanceID": {
          "description": "NEW: Unique string used to identify a unique instance of a form. Used for tracking form responses across time and across multiple episodes of editing by end-users. This string does not change for each edit session of a package instance.",
          "type": "string"
        },
        "instanceVersion": {
          "description": "NEW: Timestamp used to identify a unique instance of a package. Used for tracking form responses across time and across multiple episodes of editing by end-users. This field must change for each edit session of a form instance.",
          "type": "string",
          "format": "date-time"
        },
        "instanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "instanceVersionPrev": {
          "description": "NEW: Unique dateTime used to identify the immediate previous instance of a package. Used for tracking form responses across time and across multiple episodes of editing by end-users. This field must change for each edit session of a form instance.",
          "type": "string",
          "format": "date-time"
        },
        "X_pkgPreviousInstanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "X_prevVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "X_pkgInstanceURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "X_pkgInstanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "X_approvalStatus": {
          "type": "string",
          "enum": [
            "inProcess",
            "preliminary",
            "approved",
            "retracted"
          ]
        },
        "X_completionStatus": {
          "type": "string",
          "enum": [
            "pending",
            "incomplete",
            "complete",
            "cancelled",
            "retracted"
          ]
        },
        "changedData": {
          "description": "Identifies existence of data that has been changed in the current \t\t\t\t\tinstance of package/form/section/question compared to the previous instance of \t\t\t\t\tthe package/form/section/question",
          "type": "boolean"
        },
        "newData": {
          "description": "Identifies existence of data that is new to the current instance \t\t\t\t\tof package, form, section, or question compared to the previous instance of the \t\t\t\t\tpackage, form, section, or question",
          "type": "boolean"
        },
        "name": {
          "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
          "type": "string"
        },
        "order": {
          "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
          "type": "number",
          "minimum": 0.0
        }
      },
      "required": [
        "packageID",
        "lineage",
        "version",
        "fullURI"
      ]
    },
    "RetrieveFormPackageType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "Admin": {
          "$ref": "#/definitions/TemplateAdminType"
        },
        "SubmissionRule": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SubmissionRuleType"
          }
        },
        "ComplianceRule": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ComplianceRuleType"
          }
        },
        "HTMLPackage": {
          "items": {
            "$ref": "#/definitions/HTMLPackageType"
          }
        },
        "XMLPackage": {
          "items": {
            "$ref": "#/definitions/XMLPackageType"
          }
        },
        "FormURL": {
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "SDCPackage": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RetrieveFormPackageType"
          }
        },
        "packageID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "pkgTitle": {
          "description": "NEW Feb 2019",
          "type": "string"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "filename": {
          "description": "NEW: filename to use when the current package instance is saved as a file.   For package containing responses, the filename may include the pkgInstanceVersionURI,   but the naming convention may be use-case-specific.",
          "type": "string"
        },
        "basedOnURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "lineage": {
          "description": "NEW: A text identifier that is used to group multiple versions of a single package. The lineage is constant for all versions of a single kind of package.   When appended to @baseURI, it can be used to retrieve all versions of one particular package.",
          "type": "string"
        },
        "version": {
          "description": "NEW: @version contains the version text for the current package. It is designed to be used in conjunction with @baseURI and @lineage.",
          "type": "string"
        },
        "fullURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "instanceID": {
          "description": "NEW: Unique string used to identify a unique instance of a form. Used for tracking form responses across time and across multiple episodes of editing by end-users. This string does not change for each edit session of a package instance.",
          "type": "string"
        },
        "instanceVersion": {
          "description": "NEW: Timestamp used to identify a unique instance of a package. Used for tracking form responses across time and across multiple episodes of editing by end-users. This field must change for each edit session of a form instance.",
          "type": "string",
          "format": "date-time"
        },
        "instanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "instanceVersionPrev": {
          "description": "NEW: Unique dateTime used to identify the immediate previous instance of a package. Used for tracking form responses across time and across multiple episodes of editing by end-users. This field must change for each edit session of a form instance.",
          "type": "string",
          "format": "date-time"
        },
        "X_pkgPreviousInstanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "X_prevVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "X_pkgInstanceURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "X_pkgInstanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "X_approvalStatus": {
          "type": "string",
          "enum": [
            "inProcess",
            "preliminary",
            "approved",
            "retracted"
          ]
        },
        "X_completionStatus": {
          "type": "string",
          "enum": [
            "pending",
            "incomplete",
            "complete",
            "cancelled",
            "retracted"
          ]
        },
        "changedData": {
          "description": "Identifies existence of data that has been changed in the current \t\t\t\t\tinstance of package/form/section/question compared to the previous instance of \t\t\t\t\tthe package/form/section/question",
          "type": "boolean"
        },
        "newData": {
          "description": "Identifies existence of data that is new to the current instance \t\t\t\t\tof package, form, section, or question compared to the previous instance of the \t\t\t\t\tpackage, form, section, or question",
          "type": "boolean"
        },
        "name": {
          "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
          "type": "string"
        },
        "order": {
          "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
          "type": "number",
          "minimum": 0.0
        }
      },
      "required": [
        "packageID",
        "lineage",
        "version",
        "fullURI"
      ]
    },
    "XMLPackageType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "DemogFormDesign": {
          "items": {
            "$ref": "#/definitions/FormDesignType"
          }
        },
        "DemogFormPkgLink": {
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "FormDesign": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FormDesignType"
          }
        },
        "FormDesignPkgLink": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LinkType"
          }
        },
        "DataElement": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DataElementType"
          }
        },
        "MapTemplate": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MappingType"
          }
        },
        "ReportDesignTemplate": {
          "type": "array",
          "items": {
            "description": "ReportDesignTemplate describes the information content of a report (e.g., sections, questions etc). This enables control of the presentation view of the user responses derived from a designated FormDesignTemplate. It allows the report presentation to look substantially different from the data-entry form view defined by the FormDesignTemplate.",
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "BeforeLoadForm": {
                "$ref": "#/definitions/EventType"
              },
              "BeforeLoadData": {
                "$ref": "#/definitions/EventType"
              },
              "BeforeShowForm": {
                "$ref": "#/definitions/EventType"
              },
              "BeforeDataSubmit": {
                "$ref": "#/definitions/EventType"
              },
              "BeforeCloseForm": {
                "$ref": "#/definitions/EventType"
              },
              "OnEvent": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/OnEventType"
                }
              },
              "Header": {
                "$ref": "#/definitions/SectionItemType"
              },
              "Body": {
                "$ref": "#/definitions/SectionItemType"
              },
              "Footer": {
                "$ref": "#/definitions/SectionItemType"
              },
              "Rules": {
                "$ref": "#/definitions/RulesType"
              },
              "targetTemplateID": {
                "description": "Globally unique identifier for the template targeted by this template",
                "type": "string"
              },
              "lineage": {
                "description": "A string identifier that is used to group multiple \t\t\t\t\t\t\tversions of a single form. The lineage is constant for all versions of a \t\t\t\t\t\t\tsingle kind of form. When appended to baseURI, it can be used to \t\t\t\t\t\t\tretrieve all versions of one particular form. Example: \t\t\t\t\t\t\t@lineage=\"Lung.Bmk.227\"",
                "type": "string"
              },
              "version": {
                "description": "@version contains the version text for the current form. \t\t\t\t\t\t\tIt is designed to be used in conjunction with @baseURI and @lineage.",
                "type": "string"
              },
              "versionPrev": {
                "description": "@versionPrev identifies the immediate previous version of \t\t\t\t\t\t\tthe current FDF. The format is the same as version. The primary role of \t\t\t\t\t\t\tthis optional attribute is to allow automated comparisons between a \t\t\t\t\t\t\tcurrent FDF and the immediate previous FDF version. This is often \t\t\t\t\t\t\thelpful when deciding whether to adopt a newer version of an FDF.",
                "type": "string"
              },
              "fullURI": {
                "$ref": "#/definitions/URI_Atype"
              },
              "filename": {
                "description": "@filename is the filename of the FDF when is saved to a \t\t\t\t\t\t\tfile storage device (e.g., a disk or USB drive). The filename appears \t\t\t\t\t\t\tinside the FDF XML to help ensure the identity of the FDF content in \t\t\t\t\t\t\tcase the saved filename (on a disk drive, etc.) has been changed for any \t\t\t\t\t\t\treason.",
                "type": "string"
              },
              "formTitle": {
                "description": "@formTitle is a human readable title for display when \t\t\t\t\t\t\tchoosing forms. Added 4/27/16",
                "type": "string"
              },
              "basedOnURI": {
                "$ref": "#/definitions/URI_Atype"
              },
              "instanceID": {
                "description": "@instanceID is unique string (e.g., a GUID) used to \t\t\t\t\t\t\tidentify a unique instance of a form, such as a form used during a \t\t\t\t\t\t\tsingle patient encounter. The @instanceID is used to track saved form \t\t\t\t\t\t\tresponses across time and across multiple episodes of editing by \t\t\t\t\t\t\tend-users. This string does not change for each edit session of a form \t\t\t\t\t\t\tor package instance. The @instanceID is required in an FDF-R; It is not \t\t\t\t\t\t\tallowed in an FDF.",
                "type": "string"
              },
              "instanceVersion": {
                "description": "@instanceVersion Timestamp is used to identify a unique instance of a form. \t\t\t\t\t\t\tUsed for tracking form responses across time and across multiple \t\t\t\t\t\t\tepisodes of editing by end-users. This field must change for each edit \t\t\t\t\t\t\tsession of a form instance. The instanceVersion is required in an FDF-R; \t\t\t\t\t\t\tIt is not allowed in an FDF.",
                "type": "string",
                "format": "date-time"
              },
              "instanceVersionURI": {
                "$ref": "#/definitions/URI_Atype"
              },
              "instanceVersionPrev": {
                "description": "NEW: Unique dateTime used to identify the immediate \t\t\t\t\t\t\tprevious instance of an form instance. Used for tracking form responses \t\t\t\t\t\t\tacross time and across multiple episodes of editing by end-users. This \t\t\t\t\t\t\tfield must change for each edit session of a form instance.",
                "type": "string",
                "format": "date-time"
              },
              "approvalStatus": {
                "description": "Describes report fitness for clinical or other action \t\t\t\t\t\t\tinProcess: currently being edited, users should not rely on results \t\t\t\t\t\t\tpreliminary: report is awaiting final review and approval approved: \t\t\t\t\t\t\treport is fit for clinical or other action; often synonymous with final \t\t\t\t\t\t\tcancelled: report/procedure has been aborted before issued retracted: \t\t\t\t\t\t\treport has been deemed unfit for clinical or other action",
                "type": "string",
                "enum": [
                  "inProcess",
                  "preliminary",
                  "approved",
                  "cancelled",
                  "retracted"
                ]
              },
              "completionStatus": {
                "description": "The extent to which a report contains all of the requested \t\t\t\t\t\t\tinformation pending: no information is yet available incomplete: some \t\t\t\t\t\t\trequested information is not yet available complete: all information is \t\t\t\t\t\t\tavailable in the requested report",
                "type": "string",
                "enum": [
                  "pending",
                  "incomplete",
                  "complete"
                ]
              },
              "changedData": {
                "description": "Identifies existence of data that has been changed in the current \t\t\t\t\tinstance of package/form/section/question compared to the previous instance of \t\t\t\t\tthe package/form/section/question",
                "type": "boolean"
              },
              "newData": {
                "description": "Identifies existence of data that is new to the current instance \t\t\t\t\tof package, form, section, or question compared to the previous instance of the \t\t\t\t\tpackage, form, section, or question",
                "type": "boolean"
              },
              "ID": {
                "$ref": "#/definitions/URI_Atype"
              },
              "baseURI": {
                "$ref": "#/definitions/URI_Atype"
              },
              "name": {
                "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                "type": "string"
              },
              "order": {
                "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                "type": "number",
                "minimum": 0.0
              }
            },
            "required": [
              "Body",
              "targetTemplateID",
              "lineage",
              "version",
              "fullURI",
              "ID"
            ]
          }
        },
        "HelperFile": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "Comment": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CommentType"
                }
              },
              "Extension": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ExtensionType"
                }
              },
              "Property": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PropertyType"
                }
              },
              "templateID": {
                "description": "Globally unique identifier for this template",
                "type": "string",
                "minLength": 1
              },
              "targetTemplateID": {
                "description": "Globally unique identifier for the template targeted by this template",
                "type": "string",
                "minLength": 1
              },
              "name": {
                "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
                "type": "string"
              },
              "type": {
                "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
                "type": "string"
              },
              "styleClass": {
                "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
                "type": "string"
              },
              "order": {
                "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
                "type": "number",
                "minimum": 0.0
              }
            },
            "required": [
              "templateID",
              "targetTemplateID"
            ]
          }
        },
        "name": {
          "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
          "type": "string"
        },
        "order": {
          "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
          "type": "number",
          "minimum": 0.0
        }
      }
    },
    "PackageItemType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "formManagerURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "format": {
          "description": "NEW enumeration",
          "type": "string",
          "enum": [
            "XML",
            "JSON",
            "HTML",
            "URI"
          ]
        },
        "packageID": {
          "$ref": "#/definitions/URI_Atype"
        },
        "title": {
          "description": "NEW",
          "type": "string"
        },
        "baseURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "filename": {
          "description": "NEW: filename to use when the current FormDesign instance is saved as a file.   For forms containing responses, the filename may include the formInstanceVersionURI,   but the naming convention may be use-case-specific.",
          "type": "string"
        },
        "basedOnURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "lineage": {
          "description": "NEW: A text identifier that is used to group multiple versions of a single form. The lineage is constant for all versions of a single kind of form.   When appended to @baseURI, it can be used to retrieve all versions of one particular form.",
          "type": "string"
        },
        "version": {
          "description": "NEW: @version contains the version text for the current form. It is designed to be used in conjuction with @baseURI and @lineage.",
          "type": "string"
        },
        "fullURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "prevVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "formInstanceURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "formInstanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "formPreviousInstanceVersionURI": {
          "$ref": "#/definitions/URI_Atype"
        },
        "changedData": {
          "description": "Identifies existence of data that has been changed in the current \t\t\t\t\tinstance of package/form/section/question compared to the previous instance of \t\t\t\t\tthe package/form/section/question",
          "type": "boolean"
        },
        "newData": {
          "description": "Identifies existence of data that is new to the current instance \t\t\t\t\tof package, form, section, or question compared to the previous instance of the \t\t\t\t\tpackage, form, section, or question",
          "type": "boolean"
        },
        "name": {
          "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
          "type": "string"
        },
        "order": {
          "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
          "type": "number",
          "minimum": 0.0
        }
      },
      "required": [
        "packageID",
        "lineage",
        "version",
        "fullURI"
      ]
    },
    "HTMLPackageType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "HTMLbase64": {
          "$ref": "#/definitions/base64Binary_Stype"
        },
        "name": {
          "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
          "type": "string"
        },
        "order": {
          "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
          "type": "number",
          "minimum": 0.0
        }
      },
      "required": [
        "HTMLbase64"
      ]
    },
    "PackageListType": {
      "type": "object",
      "properties": {
        "Comment": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommentType"
          }
        },
        "Extension": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionType"
          }
        },
        "Property": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PropertyType"
          }
        },
        "PackageItem": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PackageItemType"
          },
          "minItems": 1
        },
        "HTML": {
          "$ref": "#/definitions/HTMLPackageType"
        },
        "name": {
          "description": "@name is a developer assigned unique identifier, similar to a unique control/object/variable name, used to provide the ability for programmatic manipulation of an element. The value of name must be unique within an FDF and FDF-R, even when FDF sections are repeated in the XML. @name values may begin with a letter or an underscore and may only contain characters that are legal for variable names. These generally include letters, numbers and underscore. The use of other characters may result in errors, depending on the programming language employed. Since XML is case-sensitive, names should not be made unique solely on the basis of alphabetic case, since many programming languages are case insensitive and cannot distinguish names based only on case differences.",
          "type": "string"
        },
        "type": {
          "description": "The @type attribute can contain custom metadata \"tokens\" for the element, chosen from a standardized list of terms. Tokens are short alphanumeric text strings, defined by the W3C Schema NMTOKEN specification, that are defined in an Implementation Guide. The type xsd:NMTOKEN represents a single string token. NMTOKEN values may consist of letters, digits, periods ( . ), hyphens ( - ), underscores ( _ ), and colons ( : ). They may start with any of these characters. (www.datypic.com/sc/xsd/t-xsd_NMTOKEN.html) @type tokens may be specific for one or more kinds of SDC elements. Multiple tokens in the type attribute should be separated by whitespace. Type tokens may be used to specify special handling by an application, and are usually used to define form display constraints, but may include other custom metadata as well. Style metadata should generally be handled with @styleClass rather than @type. @type token examples include: tooltip, statusLineText, alignTopLeft, align:bottom, _pageBreak-after, etc. @type metadata should generally not affect the information content of a form.",
          "type": "string"
        },
        "styleClass": {
          "description": "@styleClass is a developer assigned class name for display styling, generally for use with an external style sheet..",
          "type": "string"
        },
        "order": {
          "description": "@order is a decimal attribute that allows the form template developer to define a sequential order for elements in a template. This serves the purpose of providing a definitive/original order to sections, questions, answer choices, etc., when required for display purposes. This is important when the original XML ordering may become disrupted due to the use of an implementation technology that does not natively support ordering (e.g., object collections), and it can also provide a check on the proper importing of the XML tree during implementation.",
          "type": "number",
          "minimum": 0.0
        }
      },
      "required": [
        "HTML"
      ]
    }
  },
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "Map": {
      "$ref": "#/definitions/MappingType"
    },
    "FormDesign": {
      "$ref": "#/definitions/FormDesignType"
    },
    "DemogFormDesign": {
      "$ref": "#/definitions/FormDesignType"
    },
    "DataElement": {
      "$ref": "#/definitions/DataElementType"
    },
    "PredActionType2": {
      "type": "object",
      "additionalProperties": false
    },
    "dt": {
      "description": "A dummy \"data type\" (dt) element to compensate for a code generator bug. Do not use this type for anything.",
      "type": "object",
      "additionalProperties": false
    },
    "TemplateAdmin": {
      "$ref": "#/definitions/TemplateAdminType"
    },
    "SDCPackage": {
      "$ref": "#/definitions/RetrieveFormPackageType"
    },
    "SDCPackageList": {
      "$ref": "#/definitions/PackageListType"
    }
  }
}